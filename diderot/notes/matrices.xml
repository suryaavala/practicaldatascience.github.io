<?xml version="1.0" encoding="UTF-8"?>
<segment name='chapter'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Vectors, matrices, and linear algebra
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Vectors, matrices, and linear algebra
]]>
</field> <!-- title_src -->
<field name='label'>
chapter:Vectors--matrices--and-linear-algebra::vectors
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::download
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::download
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><a href="matrices.tar.gz">Download notes as jupyter notebook</a></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
[Download notes as jupyter notebook](matrices.tar.gz)
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Introduction
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Introduction
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::introduction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::vector
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::vector
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Vector and matrices play a central role in data science: they are probably the most common way of representing data to be analyzed and manipulated by virtually any machine learning or analytics algorithm. However, it is also important to understand that there really two uses to matrices within data science:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Vector and matrices play a central role in data science: they are probably the most common way of representing data to be analyzed and manipulated by virtually any machine learning or analytics algorithm.  However, it is also important to understand that there really two uses to matrices within data science:
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::matrices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::matrices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<ol type="1">
<li>Matrices are the “obvious” way to store tabular data (particularly when all the data is numeric) in an efficient manner.</li>
<li>Matrices are the foundation of linear algebra, which the “language” of most machine learning and analytics algorithms.</li>
</ol>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
1. Matrices are the "obvious" way to store tabular data (particularly when all the data is numeric) in an efficient manner.
2. Matrices are the foundation of linear algebra, which the "language" of most machine learning and analytics algorithms.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::understand
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::understand
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In is important to understand these two points but also the differences between them. Under the first interpretation, matrices are essentially 2D arrays (vectors are 1D arrays, and tensors are higher-dimensional arrays); this view is fundamentally a take on how to efficiently store data in the multi-dimensional arrays. But matrices are also the basic unit of linear algebra, which is a mathematical language for the expression and manipulation of linear systems of equations. There are naturally overlaps between the two, but the core operations of linear algebra, such as matrix multiplication and solving linear systems of equations, are largely orthogonal to the way in which matrices are stored as arrays in memory. Note: It is also the case that most (but definitely not all) treatments of tensors is data science actually don’t do much of the second: tensors are often a nice way to store higher-dimensional tabular data, but the actual linear algebra of tensors is relatively rare despite the recent uptick of the term “tensor” in data science.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In is important to understand these two points but also the differences between them.  Under the first interpretation, matrices are essentially 2D arrays (vectors are 1D arrays, and tensors are higher-dimensional arrays); this view is fundamentally a take on how to efficiently store data in the multi-dimensional arrays.  But matrices are also the basic unit of linear algebra, which is a mathematical language for the expression and manipulation of linear systems of equations.  There are naturally overlaps between the two, but the core operations of linear algebra, such as matrix multiplication and solving linear systems of equations, are largely orthogonal to the way in which matrices are stored as arrays in memory.  Note: It is also the case that most (but definitely not all) treatments of tensors is data science actually don't do much of the second: tensors are often a nice way to store higher-dimensional tabular data, but the actual linear algebra of tensors is relatively rare despite the recent uptick of the term "tensor" in data science.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::take
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::take
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>These notes will take us first through the “array” view of vectors and matrices, then to the “linear algebra” view. We will then learn the basics of the <a href="http://www.numpy.org/">numpy</a> library to manipulate numpy arrays both as arrays and as matrices. We will finish by discussing sparse matrices, which are particularly crucial for many data science applications.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
These notes will take us first through the "array" view of vectors and matrices, then to the "linear algebra" view.  We will then learn the basics of the [numpy](http://www.numpy.org/) library to manipulate numpy arrays both as arrays and as matrices.  We will finish by discussing sparse matrices, which are particularly crucial for many data science applications.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Vectors and matrices: the “array” view
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Vectors and matrices: the "array" view
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::vectors
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::vectors
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::vectors
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Vectors are 1D arrays of values. We use the notation <span class="math inline">\(x \in \mathbb{R}^n\)</span> to denote that <span class="math inline">\(x\)</span> is a vector with <span class="math inline">\(n\)</span> entries and in this case the entries are all real valued. We can consider other types of values for vectors (and in code we will commonly create vectors of Booleans or integers), but as mathematical objects it’s most common to use real numbers. We can write the elements of a vector more explicitly like so</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Vectors are 1D arrays of values.  We use the notation $x \in \mathbb{R}^n$ to denote that $x$ is a vector with $n$ entries and in this case the entries are all real valued.  We can consider other types of values for vectors (and in code we will commonly create vectors of Booleans or integers), but as mathematical objects it's most common to use real numbers.  We can write the elements of a vector more explicitly like so
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_2_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_1_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
x = \left[\begin{array}{c} x_1 \\ x_2 \\ \vdots \\ x_n \end{array} \right ]
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
x = \left[\begin{array}{c} x_1 \\ x_2 \\ \vdots \\ x_n \end{array} \right ]
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::denote
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::denote
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>where we use <span class="math inline">\(x_i\)</span> to denote the <span class="math inline">\(i\)</span>th element of the vector. We also note that as far as the mathematical representation of vectors goes, we will consider vectors by default to be <em>column</em> vectors (matrices with one column and many rows), as opposed to row vectors; but for example, the Numpy library doesn’t make this distinction, so this will be largely for mathematical reasons. If we want to denote a row vector, we’ll use the notation <span class="math inline">\(x^T\)</span> (<span class="math inline">\(x\)</span> transposed, for the transpose operator we’ll define shortly).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
where we use $x_i$ to denote the $i$th element of the vector.  We also note that as far as the mathematical representation of vectors goes, we will consider vectors by default to be _column_ vectors (matrices with one column and many rows), as opposed to row vectors; but for example, the Numpy library doesn't make this distinction, so this will be largely for mathematical reasons.  If we want to denote a row vector, we'll use the notation $x^T$ ($x$ transposed, for the transpose operator we'll define shortly).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::arrays
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::arrays
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Matrices are 2D arrays of values, and we use the notation <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span> to denote a matrix with <span class="math inline">\(m\)</span> rows and <span class="math inline">\(n\)</span> columns. We can write out the elements explicitly as follows</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Matrices are 2D arrays of values, and we use the notation $A \in \mathbb{R}^{m \times n}$ to denote a matrix with $m$ rows and $n$ columns.  We can write out the elements explicitly as follows
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::cccc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::cccc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A = \left[\begin{array}{cccc} 
A_{11} &amp; A_{12} &amp; \cdots &amp; A_{1n} \\ 
A_{21} &amp; A_{22} &amp; \cdots &amp; A_{2n} \\ 
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 
A_{m1} &amp; A_{m2} &amp; \cdots &amp; A_{mn}
\end{array} \right ]
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A = \left[\begin{array}{cccc} 
A_{11} & A_{12} & \cdots & A_{1n} \\ 
A_{21} & A_{22} & \cdots & A_{2n} \\ 
\vdots & \vdots & \ddots & \vdots \\ 
A_{m1} & A_{m2} & \cdots & A_{mn}
\end{array} \right ]
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::denotes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::denotes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>where <span class="math inline">\(A_ij\)</span> denotes the entry of <span class="math inline">\(A\)</span> in the <span class="math inline">\(i\)</span>th row and <span class="math inline">\(j\)</span>th column. We will use the notation <span class="math inline">\(A_{i:}\)</span> to refer to the <span class="math inline">\(i\)</span>th row of <span class="math inline">\(A\)</span> and the <span class="math inline">\(A_{:j}\)</span> to refer to the <span class="math inline">\(j\)</span>th column of <span class="math inline">\(A\)</span> (whether these represent row or column vectors depends somewhat on the situation, but we will explicitly clarify which it means whenever we use such notation).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
where $A_ij$ denotes the entry of $A$ in the $i$th row and $j$th column.  We will use the notation $A_{i:}$ to refer to the $i$th row of $A$ and the $A_{:j}$ to refer to the $j$th column of $A$ (whether these represent row or column vectors depends somewhat on the situation, but we will explicitly clarify which it means whenever we use such notation).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::higher
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::higher
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>There are also higher order generalizations of matrices (called tensors), which represented 3D or higher arrays of values. These are in fairly common use in modern data science, though typically (but certainly not always), tensors are just used in the “multi-dimensional array” sense, not in their true linear algebra sense. Tensors as linear operators that act on e.g. matrices or other higher-order tensors, are slightly less common most basic data science, and are a more advanced topic that is outside the scope of this course.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
There are also higher order generalizations of matrices (called tensors), which represented 3D or higher arrays of values.  These are in fairly common use in modern data science, though typically (but certainly not always), tensors are just used in the "multi-dimensional array" sense, not in their true linear algebra sense.  Tensors as linear operators that act on e.g. matrices or other higher-order tensors, are slightly less common most basic data science, and are a more advanced topic that is outside the scope of this course.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Matrices for tabular data and row/column ordering
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Matrices for tabular data and row/column ordering
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::matrices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::start
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::start
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s start with a simple example representing tabular data using matrices, one of the more natural ways to represent such data (and as we will see in later lectures, one of the ways that lends itself well to use in machine learning). Let’s consider the “Grades” table that we previously discussed in our presentation of relational data:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's start with a simple example representing tabular data using matrices, one of the more natural ways to represent such data (and as we will see in later lectures, one of the ways that lends itself well to use in machine learning).  Let's consider the "Grades" table that we previously discussed in our presentation of relational data:
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::person
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::person
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Person ID</th>
<th style="text-align: center;">HW1 Grade</th>
<th style="text-align: center;">HW2 Grade</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">85</td>
<td style="text-align: center;">95</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">60</td>
</tr>
<tr class="odd">
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
</tr>
</tbody>
</table>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
| Person ID | HW1 Grade | HW2 Grade |
| :---: | :---: | :---: |
| 5 | 85 | 95 | 
| 6 | 80 | 60 |
| 100 | 100 | 100 |
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ignoring
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ignoring
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Ignoring the primary key column (this is not really a numeric feature, so makes less sense to store as a real-valued number), we could represent the data in the table via the matrix</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Ignoring the primary key column (this is not really a numeric feature, so makes less sense to store as a real-valued number), we could represent the data in the table via the matrix
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::cc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::cc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A \in \mathbb{R}^{3 \times 2} = \left[ \begin{array}{cc} 85 &amp; 95 \\ 80 &amp; 60 \\ 100 &amp; 100 \end{array} \right ]
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A \in \mathbb{R}^{3 \times 2} = \left[ \begin{array}{cc} 85 & 95 \\ 80 & 60 \\ 100 & 100 \end{array} \right ]
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::seems
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::seems
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>While there seems to be little else that can be said at this point, there is actually a subtle but important point about how the data in this table is really laid out in memory. Since data in memory is laid out sequentially (at least logically as far as programs are concerned, if not physically on the chip) we can opt to store the data in <em>row major order</em>, that is, storing each row sequentially</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
While there seems to be little else that can be said at this point, there is actually a subtle but important point about how the data in this table is really laid out in memory.  Since data in memory is laid out sequentially (at least logically as far as programs are concerned, if not physically on the chip) we can opt to store the data in _row major order_, that is, storing each row sequentially
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_4_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_3_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
(85, 95, 80, 60, 100, 100)
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
(85, 95, 80, 60, 100, 100)
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::column
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::column
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>or in <em>column major order</em>, storing each column sequentially</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
or in _column major order_, storing each column sequentially
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_6_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_5_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
(85, 80, 100, 95, 60, 100)
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
(85, 80, 100, 95, 60, 100)
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::major
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::major
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Row major ordering is the default for 2D arrays in C (and the default for the Numpy library), while column major ordering is the default for FORTRAN. There is no obvious reason to prefer one over the order, but due to the cache locality in CPU memory hierarchies, the different methods will be able to access the data more efficiently by row or by column respectively. Most importantly, however, the real issue is that because a large amount of numerical code was originally (and still is) written in FORTRAN, if you ever want to call external numerical code, there is a good chance you’ll need to worry about the ordering.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Row major ordering is the default for 2D arrays in C (and the default for the Numpy library), while column major ordering is the default for FORTRAN.  There is no obvious reason to prefer one over the order, but due to the cache locality in CPU memory hierarchies, the different methods will be able to access the data more efficiently by row or by column respectively.  Most importantly, however, the real issue is that because a large amount of numerical code was originally (and still is) written in FORTRAN, if you ever want to call external numerical code, there is a good chance you'll need to worry about the ordering.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Basics of linear algebra
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Basics of linear algebra
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::basics
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::addition
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::addition
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In addition to serving as a method for storing tabular data, vector and matrices also provide a method for studying sets of linear equations. These notes here are going to provide a very brief overview and summary of some of the primary linear algebra notation that you’ll need for this course. But it is really meant to be a refresher for those who already have some experience with linear algebra previously. If you do not, then I have previously put out an online mini-course covering (with notes) some of the basics of linear algebra: <a href="http://www.cs.cmu.edu/~zkolter/course/linalg/">Linear Algebra Review</a>. This course honestly goes a bit beyond what is needed for this particular course, but it can act a good reference.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In addition to serving as a method for storing tabular data, vector and matrices also provide a method for studying sets of linear equations.  These notes here are going to provide a very brief overview and summary of some of the primary linear algebra notation that you'll need for this course.  But it is really meant to be a refresher for those who already have some experience with linear algebra previously.  If you do not, then I have previously put out an online mini-course covering (with notes) some of the basics of linear algebra: [Linear Algebra Review](http://www.cs.cmu.edu/~zkolter/course/linalg/).  This course honestly goes a bit beyond what is needed for this particular course, but it can act a good reference.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Consider the following two linear equations in two variables <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Consider the following two linear equations in two variables $x_1$ and $x_2$.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::-13
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::-13
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
\begin{split}
4 x_1 - 5 x_2 &amp; = -13 \\
-2 x_1 + 3 x_2 &amp; = 9
\end{split}
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
\begin{split}
4 x_1 - 5 x_2 & = -13 \\
-2 x_1 + 3 x_2 & = 9
\end{split}
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::written
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::written
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This can written compactly as the equation <span class="math inline">\(A x = b\)</span>, where</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This can written compactly as the equation $A x = b$, where
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::-5
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::-5
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A \in \mathbb{R}^{2 \times 2} = \left [ \begin{array}{cc} 4 &amp; -5 \\ -2 &amp; 3 \end{array} \right ], 
\;\; b \in \mathbb{R}^2 = \left [ \begin{array}{c} -13 \\ 9 \end{array} \right ], 
\;\; x \in \mathbb{R}^2 = \left [ \begin{array}{c} x_1 \\ x_2 \end{array} \right ].
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A \in \mathbb{R}^{2 \times 2} = \left [ \begin{array}{cc} 4 & -5 \\ -2 & 3 \end{array} \right ], 
\;\; b \in \mathbb{R}^2 = \left [ \begin{array}{c} -13 \\ 9 \end{array} \right ], 
\;\; x \in \mathbb{R}^2 = \left [ \begin{array}{c} x_1 \\ x_2 \end{array} \right ].
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::hopefully
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::hopefully
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>As this hopefully illustrates, one of the entire points of linear algebra is to make the notation and math <em>simpler</em> rather than more complex. However, until you get used to the conventions, writing large equations where the size of matrices/vectors are always implicit can be a bit tricky, so you’ll some care is needed to make sure you do not include any incorrect derivations.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
As this hopefully illustrates, one of the entire points of linear algebra is to make the notation and math _simpler_ rather than more complex.  However, until you get used to the conventions, writing large equations where the size of matrices/vectors are always implicit can be a bit tricky, so you'll some care is needed to make sure you do not include any incorrect derivations.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Basic operations and special matrices
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Basic operations and special matrices
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::basic
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::substraction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::substraction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Addition and substraction</strong>: Matrix addition and subtraction are applied elementwise over the matrices, and can only apply two two matrices of the same size. That is, if <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span> and <span class="math inline">\(B \in \mathbb{R}^{m \times n}\)</span> then their sum/difference <span class="math inline">\(C = A + B\)</span> is another matrix of the same size <span class="math inline">\(C \in \mathbb{R}^{m \times n}\)</span> where</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Addition and substraction**: Matrix addition and subtraction are applied elementwise over the matrices, and can only apply two two matrices of the same size.  That is, if $A \in \mathbb{R}^{m \times n}$ and $B \in \mathbb{R}^{m \times n}$ then their sum/difference $C = A + B$ is another matrix of the same size $C \in \mathbb{R}^{m \times n}$ where
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ij
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ij
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
C_{ij} = A_{ij} + B_{ij}.
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
C_{ij} = A_{ij} + B_{ij}.
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::transpose
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::transpose
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Transpose</strong>: Transposing a matrix flips its rows and columns. That is, if <span class="math inline">\(A \in \mathbb{R}^n\)</span>, then it’s transpose, denoted <span class="math inline">\(C = A^T\)</span> is a matrix <span class="math inline">\(C \in \mathbb{R}^{n \times m}\)</span> where</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Transpose**: Transposing a matrix flips its rows and columns.  That is, if $A \in \mathbb{R}^n$, then it's transpose, denoted $C = A^T$ is a matrix $C \in \mathbb{R}^{n \times m}$ where
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ji
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ji
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
C_{ij} = A_{ji}.
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
C_{ij} = A_{ji}.
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::matrix
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::matrix
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Matrix multiplication</strong>: Matrix multiplication is a bit more involved. Unlike addition and subtraction, matrix multiplication does not perform elementwise multiplication of the two matrices. Instead, for a matrix <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span>, <span class="math inline">\(B \in \mathbb{R}^{n \times p}\)</span> (note these precise sizes, as they are important), their product <span class="math inline">\(C = AB\)</span> is a matrix <span class="math inline">\(C \in \mathbb{R}^{m \times p}\)</span> where</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Matrix multiplication**: Matrix multiplication is a bit more involved.  Unlike addition and subtraction, matrix multiplication does not perform elementwise multiplication of the two matrices.  Instead, for a matrix $A \in \mathbb{R}^{m \times n}$, $B \in \mathbb{R}^{n \times p}$ (note these precise sizes, as they are important), their product $C = AB$ is a matrix $C \in \mathbb{R}^{m \times p}$ where
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ik
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ik
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
C_{ij} = \sum_{k=1}^n A_{ik} B_{kj}.
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
C_{ij} = \sum_{k=1}^n A_{ik} B_{kj}.
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::order
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::order
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In order for this sum to make sense, notice that the number of columns in <span class="math inline">\(A\)</span> must equal the number of rows in <span class="math inline">\(B\)</span>. If you’d like a bit more of the intuition behind why matrix multiplication is defined this way, the notes above provide some important interpretations. It’s important to note the following properties, though:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In order for this sum to make sense, notice that the number of columns in $A$ must equal the number of rows in $B$.  If you'd like a bit more of the intuition behind why matrix multiplication is defined this way, the notes above provide some important interpretations.  It's important to note the following properties, though:
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::multiplication
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::multiplication
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<ul>
<li>Matrix multiplication is associative: <span class="math inline">\((AB)C = A(BC)\)</span> (i.e., it doesn’t matter in what order you do the multiplications, though it <em>can</em> matter from a computational perspective, as some orderings will be more efficient to compute than others)</li>
<li>Matrix multiplication is distributive: <span class="math inline">\(A(B+C) = AB + AC\)</span></li>
<li>Matrix multiplication is <em>not</em> commutative: <span class="math inline">\(AB \neq BA\)</span>. This is really true in two different ways. Under the above matrix sizes, the multiplication <span class="math inline">\(BA\)</span> is not a valid expression if <span class="math inline">\(m \neq p\)</span> (since the number of columns in <span class="math inline">\(B\)</span> would not match the number of rows in <span class="math inline">\(A\)</span>). And even if the dimensions <em>do</em> match (for instance if all the matrices were <span class="math inline">\(n \times n\)</span>) the products will still not be equal in general.</li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
* Matrix multiplication is associative: $(AB)C = A(BC)$ (i.e., it doesn't matter in what order you do the multiplications, though it _can_ matter from a computational perspective, as some orderings will be more efficient to compute than others)
* Matrix multiplication is distributive: $A(B+C) = AB + AC$
* Matrix multiplication is _not_ commutative: $AB \neq BA$. This is really true in two different ways.  Under the above matrix sizes, the multiplication $BA$ is not a valid expression if $m \neq p$ (since the number of columns in $B$ would not match the number of rows in $A$).  And even if the dimensions _do_ match (for instance if all the matrices were $n \times n$) the products will still not be equal in general.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::identity
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::identity
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Identity matrix</strong>: The identity matrix <span class="math inline">\(I \in \mathbb{R}^{n \times n}\)</span> is a square matrix with ones on the diagonal an zeros everywhere else</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Identity matrix**: The identity matrix $I \in \mathbb{R}^{n \times n}$ is a square matrix with ones on the diagonal an zeros everywhere else
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_8_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_7_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
I = \left [ \begin{array}{cccc} 
1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 
0 &amp; 0 &amp; \cdots &amp; 1
\end{array} \right ].
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
I = \left [ \begin{array}{cccc} 
1 & 0 & \cdots & 0 \\
0 & 1 & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\ 
0 & 0 & \cdots & 1
\end{array} \right ].
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::property
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::property
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>It has the property that for any matrix <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
It has the property that for any matrix $A \in \mathbb{R}^{m \times n}$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_10_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_9_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A I = I A = A
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A I = I A = A
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::equations
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::equations
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>where we note that the two <span class="math inline">\(I\)</span> matrices in the above equations are actually two <em>different</em> sizes (the first one is $ n n$ and the second is <span class="math inline">\(m \times m\)</span>, to make the math work right). For this reason, some people use the notation <span class="math inline">\(I_n\)</span> to explicitly denote the size of <span class="math inline">\(I\)</span>, but it is not really needed, because the size that any identity must be can be inferred from the other matrices in the equation.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
where we note that the two $I$ matrices in the above equations are actually two _different_ sizes (the first one is $ n \times n$ and the second is $m \times m$, to make the math work right).  For this reason, some people use the notation $I_n$ to explicitly denote the size of $I$, but it is not really needed, because the size that any identity must be can be inferred from the other matrices in the equation.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::matix
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::matix
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Matix inverse</strong>: For a square matrix <span class="math inline">\(A \in \mathbb{R}^{n \times n}\)</span>, the matrix inverse <span class="math inline">\(A^{-1} \in \mathbb{R}^{n \times n}\)</span> is the unique matrix such that</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Matix inverse**: For a square matrix $A \in \mathbb{R}^{n \times n}$, the matrix inverse $A^{-1} \in \mathbb{R}^{n \times n}$ is the unique matrix such that
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::-1
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::-1
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A^{-1}A = A A^{-1} = I.
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A^{-1}A = A A^{-1} = I.
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::inverse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::inverse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The matrix inverse need not exist for all square matrices (it will depend on the linear independence between rows/columns of <span class="math inline">\(A\)</span>, and we will consider such possibilities a bit later in the course.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The matrix inverse need not exist for all square matrices (it will depend on the linear independence between rows/columns of $A$, and we will consider such possibilities a bit later in the course.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::solving
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::solving
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Solving linear equations</strong>: The matrix inverse provides an immediate method to obtain the solution to systems of linear equations. Recall out example above of a set of linear equations <span class="math inline">\(A x = b\)</span>. If we want to find the <span class="math inline">\(x\)</span> that satisfies this equation, we multiply both sizes of the equation by <span class="math inline">\(A^{-1}\)</span> on the left to get</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Solving linear equations**: The matrix inverse provides an immediate method to obtain the solution to systems of linear equations.  Recall out example above of a set of linear equations $A x = b$.  If we want to find the $x$ that satisfies this equation, we multiply both sizes of the equation by $A^{-1}$ on the left to get
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_12_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_11_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A^{-1}A x = A^{-1}b \Longrightarrow x = A^{-1} b.
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A^{-1}A x = A^{-1}b \Longrightarrow x = A^{-1} b.
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::nice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::nice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The nice thing here is that as far as we are concerned in this course, the set of equations is now <em>solved</em>. We don’t have to worry about any actual operations that you may have learned about to actually obtain this solution (scaling the linear equations by some constant, adding/subtracting them to construct a solution, etc). The linear algebra libraries we will use do all this for us, and our only concern is getting the solution into a form like the one above.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The nice thing here is that as far as we are concerned in this course, the set of equations is now _solved_.  We don't have to worry about any actual operations that you may have learned about to actually obtain this solution (scaling the linear equations by some constant, adding/subtracting them to construct a solution, etc).  The linear algebra libraries we will use do all this for us, and our only concern is getting the solution into a form like the one above.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::product
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::product
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Transpose of matrix product</strong>: It follows immediately from the definition of matrix multiplication and the transpose that</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Transpose of matrix product**: It follows immediately from the definition of matrix multiplication and the transpose that
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ab
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ab
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
(AB)^T = B^T A^T
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
(AB)^T = B^T A^T
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::transposes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::transposes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>i.e., the transpose of a matrix product is the product of the transposes, in reverse order.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
i.e., the transpose of a matrix product is the product of the transposes, in reverse order.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::follows
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::follows
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Inverse of matrix</strong>: It also follows immediately from the definitions that for <span class="math inline">\(A,B\in \mathbb{R}^{n \times n}\)</span> both square</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Inverse of matrix**: It also follows immediately from the definitions that for $A,B\in \mathbb{R}^{n \times n}$ both square
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_14_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_13_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
(AB)^{-1} = B^{-1} A^{-1}
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
(AB)^{-1} = B^{-1} A^{-1}
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::inverses
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::inverses
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>i.e. the inverse of a matrix product is the product of the inverses, in reverse order.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
i.e. the inverse of a matrix product is the product of the inverses, in reverse order.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::inner
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::inner
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Inner products</strong>: One type of matrix multiplication is common enough that it deserves special mention. If <span class="math inline">\(x,y \in \mathbb{R}^n\)</span> are vectors of the same dimensions, then</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Inner products**: One type of matrix multiplication is common enough that it deserves special mention.  If $x,y \in \mathbb{R}^n$ are vectors of the same dimensions, then
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_16_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_15_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
x^T y = \sum_{i=1}^n x_i y_i
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
x^T y = \sum_{i=1}^n x_i y_i
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::transposed
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::transposed
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>(the matrix product of <span class="math inline">\(x\)</span> transposed, i.e., a row vector and <span class="math inline">\(y\)</span>, a column vector) is a <em>scalar</em> quantity called the inner product of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>; it is simply equal to the sum of the corresponding elements of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> multiplied together.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
(the matrix product of $x$ transposed, i.e., a row vector and $y$, a column vector) is a _scalar_ quantity called the inner product of $x$ and $y$; it is simply equal to the sum of the corresponding elements of $x$ and $y$ multiplied together.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::norms
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::norms
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Vector norms</strong>: These are only slightly related to vectors matrices, but this seems like a good place to introduce it. We will use the notation</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Vector norms**: These are only slightly related to vectors matrices, but this seems like a good place to introduce it.  We will use the notation
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_18_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_17_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
\|x\|_2 = \sqrt{x^T x} = \sqrt{\sum_{i=1}^n x_i^2}
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
\|x\|_2 = \sqrt{x^T x} = \sqrt{\sum_{i=1}^n x_i^2}
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::euclidean
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::euclidean
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>to denote the Euclidean (also called <span class="math inline">\(\ell_2\)</span>) norm of <span class="math inline">\(x\)</span>. We may occasionally also refer to the <span class="math inline">\(\ell_1\)</span> norm</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
to denote the Euclidean (also called $\ell_2$) norm of $x$.  We may occasionally also refer to the $\ell_1$ norm
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_20_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_19_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
\|x\|_1 = \sum_{i=1}^n |x_i|
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
\|x\|_1 = \sum_{i=1}^n |x_i|
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::norm
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::norm
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>or the <span class="math inline">\(\ell_\infty\)</span> norm</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
or the $\ell_\infty$ norm
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_22_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_21_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
\|x\|_\infty = \max_{i=1,\ldots,n} |x_i|.
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
\|x\|_\infty = \max_{i=1,\ldots,n} |x_i|.
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::complexity
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::complexity
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>** Complexity of operations**: For making efficient use of matrix operations, it is extremely important to know the big-O complexity of the different matrix operations. Immediately from the definitions of the operations, assuming <span class="math inline">\(A,B \in \mathbb{R}^{n \times n}\)</span> and <span class="math inline">\(x,y \in \mathbb{R}^n\)</span> we have the the following complexities:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
** Complexity of operations**:  For making efficient use of matrix operations, it is extremely important to know the big-O complexity of the different matrix operations.  Immediately from the definitions of the operations, assuming $A,B \in \mathbb{R}^{n \times n}$ and $x,y \in \mathbb{R}^n$ we have the the following complexities:
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::matrix-vector
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::matrix-vector
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<ul>
<li>Inner product <span class="math inline">\(x^Ty\)</span>: <span class="math inline">\(O(n)\)</span></li>
<li>Matrix-vector product <span class="math inline">\(Ax\)</span>: <span class="math inline">\(O(n^2)\)</span></li>
<li>Matrix-matrix product <span class="math inline">\(AB\)</span>: <span class="math inline">\(O(n^3)\)</span></li>
<li>Matrix inverse <span class="math inline">\(A^{-1}\)</span>, or matrix solve <span class="math inline">\(A^{-1}y\)</span> (as we will emphasize below, these are arctually done differently; they both have the same big-O omplexity, but different concstant terms on the runtime in practice): <span class="math inline">\(O(n^3)\)</span></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
* Inner product $x^Ty$: $O(n)$
* Matrix-vector product $Ax$: $O(n^2)$
* Matrix-matrix product $AB$: $O(n^3)$
* Matrix inverse $A^{-1}$, or matrix solve $A^{-1}y$ (as we will emphasize below, these are arctually done differently; they both have the same big-O omplexity, but different concstant terms on the runtime in practice): $O(n^3)$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::big-o
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::big-o
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note that the big-O complexity along with the associative property of matrix multiplications implies very different complexities for computing the exact same term in different ways. For example, suppose we want to compute the matrix products <span class="math inline">\(ABx\)</span>. We could compute this as <span class="math inline">\((AB)x\)</span> (computing the <span class="math inline">\(AB\)</span> product first, then multiplying with <span class="math inline">\(x\)</span>); this approach would have complexity <span class="math inline">\(O(n^3)\)</span>, as the matrix-matrix product would dominate the computation. On the other hand, if we compute the product as <span class="math inline">\(A(Bx)\)</span> (first computing the vector product <span class="math inline">\(Bx\)</span>, which produces a vector, then multiplying this by <span class="math inline">\(A\)</span>), the complex is only <span class="math inline">\(O(n^2)\)</span>, as we just have two matrix-vector products. As you can imagine, these orders of operations therefore make a huge difference in terms of the time complexity of linear algebra operations.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note that the big-O complexity along with the associative property of matrix multiplications implies very different complexities for computing the exact same term in different ways.  For example, suppose we want to compute the matrix products $ABx$.  We could compute this as $(AB)x$ (computing the $AB$ product first, then multiplying with $x$); this approach would have complexity $O(n^3)$, as the matrix-matrix product would dominate the computation.  On the other hand, if we compute the product as $A(Bx)$ (first computing the vector product $Bx$, which produces a vector, then multiplying this by $A$), the complex is only $O(n^2)$, as we just have two matrix-vector products.  As you can imagine, these orders of operations therefore make a huge difference in terms of the time complexity of linear algebra operations.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Numpy and software for matrices
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Numpy and software for matrices
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::numpy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::numpy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::numpy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The Numpy library is the defacto standard for manipulating matrices and vectors (and higher order tensors) from within Python. Numpy <code>ndarray</code> objects are fundamentally multi-dimensional arrays, but the library also includes a variety of functions for processing these like matrices/vectors. A key aspect of this library is that numpy matrices vectors are stored efficiently in memory, not via Python lists, and the operations in numpy are back by efficiently implemented linear algebra libraries.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The Numpy library is the defacto standard for manipulating matrices and vectors (and higher order tensors) from within Python.  Numpy `ndarray` objects are fundamentally multi-dimensional arrays, but the library also includes a variety of functions for processing these like matrices/vectors.  A key aspect of this library is that numpy matrices vectors are stored efficiently in memory, not via Python lists, and the operations in numpy are back by efficiently implemented linear algebra libraries.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::complete
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::complete
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A more complete tutorial on numpy is available here: <a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html">Numpy tutorial</a>. But these notes will introduce you to some of the basic operations you’re likely to see repeatedly in many data science applications.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A more complete tutorial on numpy is available here: [Numpy tutorial](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html).  But these notes will introduce you to some of the basic operations you're likely to see repeatedly in many data science applications.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Specialized linear algebra libraies
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Specialized linear algebra libraies
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::specialized
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::appreciate
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::appreciate
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>As you will hopefully appreciate throughout this course, linear algebra computations underly virtually all data science and machine learning algorithms. Thus, making these algorithms fast is extremely important in practical applications. And despite the seeming “simplicity” of basic linear algebra operators, the naive implementation of most algorithms will perform quite poorly. Consider the following (in C) implementation of a matrix multiplication operator.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
As you will hopefully appreciate throughout this course, linear algebra computations underly virtually all data science and machine learning algorithms.  Thus, making these algorithms fast is extremely important in practical applications.  And despite the seeming "simplicity" of basic linear algebra operators, the naive implementation of most algorithms will perform quite poorly.  Consider the following (in C) implementation of a matrix multiplication operator.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::void
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::void
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">void</span> matmul(<span class="dt">double</span> **A, <span class="dt">double</span> **B, <span class="dt">double</span> **C, <span class="dt">int</span> m, <span class="dt">int</span> n, <span class="dt">int</span> p) {</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {</a>
<a class="sourceLine" id="cb1-3" title="3">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; p; j++) {</a>
<a class="sourceLine" id="cb1-4" title="4">            C[i][j] = <span class="fl">0.0</span>;</a>
<a class="sourceLine" id="cb1-5" title="5">            <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++)</a>
<a class="sourceLine" id="cb1-6" title="6">                C[i][j] += A[i][k] * B[k][j];</a>
<a class="sourceLine" id="cb1-7" title="7">        }</a>
<a class="sourceLine" id="cb1-8" title="8">    }</a>
<a class="sourceLine" id="cb1-9" title="9">}</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```c
void matmul(double **A, double **B, double **C, int m, int n, int p) {
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < p; j++) {
            C[i][j] = 0.0;
            for (int k = 0; k < n; k++)
                C[i][j] += A[i][k] * B[k][j];
        }
    }
}
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::sense
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::sense
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In some sense, it seems like this <em>has</em> to be the implementation of matrix multiply; it is just a simple translation of the mathematical definition to code. But if you compiled this code, and profile it against an optimized linear algebra library, you can expect about 10 <em>times</em> slower performance. How is this happening?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In some sense, it seems like this _has_ to be the implementation of matrix multiply; it is just a simple translation of the mathematical definition to code.  But if you compiled this code, and profile it against an optimized linear algebra library, you can expect about 10 _times_ slower performance.  How is this happening?
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::turns
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::turns
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>It turns out that (precisely because linear algebra is so crucial), specialized linear algebra libraries (these include, for instance, <a href="http://www.openblas.net/">OpenBLAS</a>, <a href="https://software.intel.com/en-us/mkl">Intel MKL</a>, <a href="http://math-atlas.sourceforge.net/">ATLAS</a> or <a href="http://eigen.tuxfamily.org/">Eigen</a>) have gone to great lengths to exploit the custom vector processors, plus the cache hierarchy of specific architectures, to make libraries that are well-tuned to each different CPU (for example, they typically use “chunking” methods to break down matrix multiplications into smaller pieces that are better suited to exploit cache locality). And the difference in speed between these and the more naive algorithms are extremely striking.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
It turns out that (precisely because linear algebra is so crucial), specialized linear algebra libraries (these include, for instance, [OpenBLAS](http://www.openblas.net/), [Intel MKL](https://software.intel.com/en-us/mkl), [ATLAS](http://math-atlas.sourceforge.net/) or [Eigen](http://eigen.tuxfamily.org/)) have gone to great lengths to exploit the custom vector processors, plus the cache hierarchy of specific architectures, to make libraries that are well-tuned to each different CPU (for example, they typically use "chunking" methods to break down matrix multiplications into smaller pieces that are better suited to exploit cache locality).  And the difference in speed between these and the more naive algorithms are extremely striking.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::reasons
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::reasons
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This is also one of the reasons why we recommend that everyone still Anaconda as their Python distribution. Anaconda comes with versions of Numpy that are compiled with a fast linear algebra library backing it. Chances are, if you compile your Numpy library locally, you will not link to these fast libraries, and the speed of your matrix-based code will suffer substantially from it.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This is also one of the reasons why we recommend that everyone still Anaconda as their Python distribution.  Anaconda comes with versions of Numpy that are compiled with a fast linear algebra library backing it.  Chances are, if you compile your Numpy library locally, you will not link to these fast libraries, and the speed of your matrix-based code will suffer substantially from it.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::check
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::check
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>To check to see if Numpy is using specialized libraries, use the command:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
To check to see if Numpy is using specialized libraries, use the command:
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::python
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::python
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb1-2" title="2">np.__config__.show()</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
import numpy as np
np.__config__.show()
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::blas
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::blas
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
blas_mkl_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
blas_opt_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
lapack_mkl_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
lapack_opt_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
blas_mkl_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
blas_opt_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
lapack_mkl_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
lapack_opt_info:
    libraries = ['mkl_rt', 'pthread']
    library_dirs = ['/Users/zkolter/anaconda3/lib']
    define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
    include_dirs = ['/Users/zkolter/anaconda3/include']
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::output
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::output
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Your output may not be exactly the same as what is shown here, but you should be able to infer from this if you’re using an optimized library like (int this case), Intel MKL.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Your output may not be exactly the same as what is shown here, but you should be able to infer from this if you're using an optimized library like (int this case), Intel MKL.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Creating numpy arrays
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Creating numpy arrays
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::creating
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ndarray
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ndarray
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The <code>ndarray</code> is the basic data type in Numpy. These can be created the <code>numpy.array</code> command, passing a 1D list of number to create a vector or a 2D list of numbers to create an array.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The `ndarray` is the basic data type in Numpy.  These can be created the `numpy.array` command, passing a 1D list of number to create a vector or a 2D list of numbers to create an array.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::array
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::array
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">b <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">13</span>,<span class="dv">9</span>])            <span class="co"># 1D array construction</span></a>
<a class="sourceLine" id="cb1-2" title="2">A <span class="op">=</span> np.array([[<span class="dv">4</span>,<span class="op">-</span><span class="dv">5</span>], [<span class="op">-</span><span class="dv">2</span>,<span class="dv">3</span>]])   <span class="co"># 2D array contruction</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(b, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="bu">print</span>(A)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
b = np.array([-13,9])            # 1D array construction
A = np.array([[4,-5], [-2,3]])   # 2D array contruction
print(b, "\n")
print(A)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::pre
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::pre
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[-13   9] 

[[ 4 -5]
 [-2  3]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[-13   9] 

[[ 4 -5]
 [-2  3]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::special
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::special
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>There are also special functions for creating arrays/matrices of all zeros, all ones, or of random numbers (in this case, the <code>np.randon.randn</code> create a matrix with standard random normal entries, while <code>np.random.rand</code> creates uniform random entries).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
There are also special functions for creating arrays/matrices of all zeros, all ones, or of random numbers (in this case, the `np.randon.randn` create a matrix with standard random normal entries, while `np.random.rand` creates uniform random entries).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::print
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::print
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(np.ones(<span class="dv">4</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)           <span class="co"># 1D array of ones</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(np.zeros(<span class="dv">4</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)          <span class="co"># 1D array of zeros</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(np.random.randn(<span class="dv">4</span>))         <span class="co"># 1D array of random normal numbers</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(np.ones(4), "\n")           # 1D array of ones
print(np.zeros(4), "\n")          # 1D array of zeros
print(np.random.randn(4))         # 1D array of random normal numbers
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::-0
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::-0
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[ 1.  1.  1.  1.] 

[ 0.  0.  0.  0.] 

[-0.65826018 -0.48547552 -0.12390373  0.51937501]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[ 1.  1.  1.  1.] 

[ 0.  0.  0.  0.] 

[-0.65826018 -0.48547552 -0.12390373  0.51937501]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::ones
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::ones
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(np.ones((<span class="dv">3</span>,<span class="dv">4</span>)), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)       <span class="co"># 2D array of ones</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(np.zeros((<span class="dv">3</span>,<span class="dv">4</span>)), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)      <span class="co"># 2D array of zeros</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(np.random.randn(<span class="dv">3</span>,<span class="dv">4</span>))       <span class="co"># 2D array of random normal numbers</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(np.ones((3,4)), "\n")       # 2D array of ones
print(np.zeros((3,4)), "\n")      # 2D array of zeros
print(np.random.randn(3,4))       # 2D array of random normal numbers
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_24_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_23_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]] 

[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]] 

[[-0.92108207 -0.0840208  -1.49748471  0.1484692 ]
 [-0.80504092  0.47344881  0.96519561  1.02125684]
 [ 0.07350312 -0.52083043 -0.42326075  0.71938146]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]] 

[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]] 

[[-0.92108207 -0.0840208  -1.49748471  0.1484692 ]
 [-0.80504092  0.47344881  0.96519561  1.02125684]
 [ 0.07350312 -0.52083043 -0.42326075  0.71938146]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::design
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::design
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note that (in a design that will forever frustrate me), the size of the array is passed as a tuple to <code>np.ones()</code> and <code>np.zeros()</code>, but as a list of arguments to <code>np.random.randn()</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note that (in a design that will forever frustrate me), the size of the array is passed as a tuple to `np.ones()` and `np.zeros()`, but as a list of arguments to `np.random.randn()`.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::create
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::create
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>You can also create the indentity matrix using the <code>np.eye()</code> command, and a diagonal matrix with the <code>np.diag()</code> command.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You can also create the indentity matrix using the `np.eye()` command, and a diagonal matrix with the `np.diag()` command.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::diag
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::diag
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(np.eye(<span class="dv">3</span>),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)                     <span class="co"># create array for 3x3 identity matrix</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(np.diag(np.random.randn(<span class="dv">3</span>)),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)   <span class="co"># create diagonal array</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(np.eye(3),"\n")                     # create array for 3x3 identity matrix
print(np.diag(np.random.randn(3)),"\n")   # create diagonal array
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_26_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_25_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]] 

[[ 0.75084381  0.          0.        ]
 [ 0.         -0.17133185  0.        ]
 [ 0.          0.         -1.09201859]] 

</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]] 

[[ 0.75084381  0.          0.        ]
 [ 0.         -0.17133185  0.        ]
 [ 0.          0.         -1.09201859]] 

</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Indexing into numpy arrays
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Indexing into numpy arrays
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::indexing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::index
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::index
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>You can index into Numpy arrays in many different ways. The most common is to index into them as you would a list: using single indices and using slices, with the additional consideration that using the <code>:</code> character will select the entire span along that dimension.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You can index into Numpy arrays in many different ways.  The most common is to index into them as you would a list: using single indices and using slices, with the additional consideration that using the `:` character will select the entire span along that dimension.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::select
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::select
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">A <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>], [<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>], [<span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>]])</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(A, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(A[<span class="dv">1</span>,<span class="dv">1</span>],<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)           <span class="co"># select singe entry</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="bu">print</span>(A[<span class="dv">1</span>,:],<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)           <span class="co"># select entire row</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="bu">print</span>(A[<span class="dv">1</span>:<span class="dv">3</span>, :], <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)       <span class="co"># slice indexing</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
A = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
print(A, "\n")
print(A[1,1],"\n")           # select singe entry
print(A[1,:],"\n")           # select entire row
print(A[1:3, :], "\n")       # slice indexing
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_28_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_27_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]] 

5 

[4 5 6] 

[[4 5 6]
 [7 8 9]] 

</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]] 

5 

[4 5 6] 

[[4 5 6]
 [7 8 9]] 

</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::convention
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::convention
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note the convention here in terms of the sizes returned: if we select a single entry, then we get back the value of that entry (not a 1D/2D array with just a singleton element). If we select a single row or a single column from a 2D array we get a <em>1D array</em> with that row or column. And if we select a slice and/or the entire row/column along both dimensions, we get a 2D array. This takes a while to get used to, but if, for example, we wanted to get a <em>2D array</em> containing just the (1,1) element, we could use the code.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note the convention here in terms of the sizes returned: if we select a single entry, then we get back the value of that entry (not a 1D/2D array with just a singleton element).  If we select a single row or a single column from a 2D array we get a _1D array_ with that row or column.  And if we select a slice and/or the entire row/column along both dimensions, we get a 2D array.  This takes a while to get used to, but if, for example, we wanted to get a _2D array_ containing just the (1,1) element, we could use the code.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::singleton
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::singleton
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A[<span class="dv">1</span>:<span class="dv">2</span>,<span class="dv">1</span>:<span class="dv">2</span>])  <span class="co"># Select A[1,1] as a singleton 2D array</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A[1:2,1:2])  # Select A[1,1] as a singleton 2D array
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_30_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_29_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[5]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[5]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::support
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::support
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Numpy also support fancier indexing with <em>integer</em> and <em>Boolean</em> indexing. If we create another array or list of indices (that is, for the rows in above array, this would be integers between 0-3 (inclusive)), then we can use this list of integers to select the rows/columns we want to include.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Numpy also support fancier indexing with _integer_ and _Boolean_ indexing.  If we create another array or list of indices (that  is, for the rows in above array, this would be integers between 0-3 (inclusive)), then we can use this list of integers to select the rows/columns we want to include.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::rows
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::rows
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],:])  <span class="co"># select rows 1, 2, and 3</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A[[1,2,3],:])  # select rows 1, 2, and 3
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_32_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_31_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 4  5  6]
 [ 7  8  9]
 [10 11 12]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 4  5  6]
 [ 7  8  9]
 [10 11 12]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::integer
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::integer
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note that these integer indices do not need to be in order, nor do they have to include at most once instance of each row/column; we can use this notation to repeat rows/columns too.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note that these integer indices do not need to be in order, nor do they have to include at most once instance of each row/column; we can use this notation to repeat rows/columns too.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_34_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_33_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A[[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>],:])  <span class="co"># select rows 2, 1, and 2 again</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A[[2,1,2],:])  # select rows 2, 1, and 2 again
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_36_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_35_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[7 8 9]
 [4 5 6]
 [7 8 9]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[7 8 9]
 [4 5 6]
 [7 8 9]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::integers
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::integers
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note that we can also use an array of integers instead of a list, for the same purpose.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note that we can also use an array of integers instead of a list, for the same purpose.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::np
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::np
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A[np.array([<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>]),:])  <span class="co"># select rows 2, 1, and 2 again</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A[np.array([2,1,2]),:])  # select rows 2, 1, and 2 again
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_38_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_37_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[7 8 9]
 [4 5 6]
 [7 8 9]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[7 8 9]
 [4 5 6]
 [7 8 9]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::boolean
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::boolean
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Last, we can also use Boolean indexing. If we specify a list or array of booleans that is the <em>same size</em> as the corresponding row/column, then the Boolean values specify a “mask” over which values are taken.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Last, we can also use Boolean indexing.  If we specify a list or array of booleans that is the _same size_ as the corresponding row/column, then the Boolean values specify a "mask" over which values are taken.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::false
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::false
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A[[<span class="va">False</span>, <span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>],:])  <span class="co"># Select 1st and 3rd rows</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A[[False, True, False, True],:])  # Select 1st and 3rd rows
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_40_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_39_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 4  5  6]
 [10 11 12]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 4  5  6]
 [10 11 12]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::final
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::final
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>As a final note, be careful if you try to use integer or boolean indexing for both dimensions. This will attempt to select generate a 1D array of entries with both those locations.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
As a final note, be careful if you try to use integer or boolean indexing for both dimensions.  This will attempt to select generate a 1D array of entries with both those locations.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_42_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_41_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A[[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>]])    <span class="co"># the same as np.array([A[2,1], A[1,2], A[2,0]])</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A[[2,1,2],[1,2,0]])    # the same as np.array([A[2,1], A[1,2], A[2,0]])
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_44_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_43_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([8, 6, 7])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([8, 6, 7])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::want
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::want
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>If you actually want to first select based upon rows, then upon columns, you’ll do it like the following, essentially doing each indexing separately.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
If you actually want to first select based upon rows, then upon columns, you'll do it like the following, essentially doing each indexing separately.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_46_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_45_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">A[[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>],:][:,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>]]</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
A[[2,1,2],:][:,[1,2,0]]
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_48_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_47_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([[8, 9, 7],
       [5, 6, 4],
       [8, 9, 7]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([[8, 9, 7],
       [5, 6, 4],
       [8, 9, 7]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Basic operations on arrays
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Basic operations on arrays
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::operations
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::added
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::added
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Arrays can be added/subtracted, multiplied/divided, and transposed, but these are <em>not</em> all the same as their linear algebra counterparts.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Arrays can be added/subtracted, multiplied/divided, and transposed, but these are _not_ all the same as their linear algebra counterparts.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::elementwise
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::elementwise
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">B <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>], [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(A<span class="op">+</span>B, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="co"># add A and B elementwise (same as &quot;standard&quot; matrix addition)</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(A<span class="op">-</span>B) <span class="co"># subtract B from A elementwise (same as &quot;standard&quot; matrix subtraction)</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
B = np.array([[1, 1, 1], [1,2,1], [3, 1, 3], [1, 4, 1]])
print(A+B, "\n") # add A and B elementwise (same as "standard" matrix addition)
print(A-B) # subtract B from A elementwise (same as "standard" matrix subtraction)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_50_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_49_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 2  3  4]
 [ 5  7  7]
 [10  9 12]
 [11 15 13]] 

[[ 0  1  2]
 [ 3  3  5]
 [ 4  7  6]
 [ 9  7 11]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 2  3  4]
 [ 5  7  7]
 [10  9 12]
 [11 15 13]] 

[[ 0  1  2]
 [ 3  3  5]
 [ 4  7  6]
 [ 9  7 11]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::division
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::division
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Array multiplication and division are done <em>elementwise</em>, they are <em>not</em> matrix multiplication or anything related to matrix inversion.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Array multiplication and division are done _elementwise_, they are _not_ matrix multiplication or anything related to matrix inversion.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::inversion
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::inversion
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A<span class="op">*</span>B, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="co"># elementwise multiplication, _not_ matrix multiplication</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(A<span class="op">/</span>B, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="co"># elementwise division, _not_ matrix inversion</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A*B, "\n") # elementwise multiplication, _not_ matrix multiplication
print(A/B, "\n") # elementwise division, _not_ matrix inversion
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_52_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_51_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 1  2  3]
 [ 4 10  6]
 [21  8 27]
 [10 44 12]] 

[[  1.           2.           3.        ]
 [  4.           2.5          6.        ]
 [  2.33333333   8.           3.        ]
 [ 10.           2.75        12.        ]] 

</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 1  2  3]
 [ 4 10  6]
 [21  8 27]
 [10 44 12]] 

[[  1.           2.           3.        ]
 [  4.           2.5          6.        ]
 [  2.33333333   8.           3.        ]
 [ 10.           2.75        12.        ]] 

</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::meaning
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::meaning
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>You can transpose arrays, but note this <em>only</em> has meaning for 2D (or higher) arrays. Transposing a 1D array doesn’t do anything, since Numpy has no notion of column vectors vs. row vectors for 1D arrays.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You can transpose arrays, but note this _only_ has meaning for 2D (or higher) arrays.  Transposing a 1D array doesn't do anything, since Numpy has no notion of column vectors vs. row vectors for 1D arrays.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_54_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_53_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">x <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(A.T, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(x, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="bu">print</span>(x.T)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
x = np.array([1,2,3,4])
print(A.T, "\n")
print(x, "\n")
print(x.T)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_56_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_55_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 1  4  7 10]
 [ 2  5  8 11]
 [ 3  6  9 12]] 

[1 2 3 4] 

[1 2 3 4]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 1  4  7 10]
 [ 2  5  8 11]
 [ 3  6  9 12]] 

[1 2 3 4] 

[1 2 3 4]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Broadcasting
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Broadcasting
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::broadcasting
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::things
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::things
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Things start to get very fun when you add/substract/multiply/divide array of <em>different</em> sizes. Rather than throw an error, Numpy will try to make sense of your operation using the <a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html">Numpy broadcasting rules</a>. This is an advanced topic, which often really throws off newcomers to Numpy, but with a bit of practice the rules become quite intuitive.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Things start to get very fun when you add/substract/multiply/divide array of _different_ sizes.  Rather than throw an error, Numpy will try to make sense of your operation using the [Numpy broadcasting rules](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html).  This is an advanced topic, which often really throws off newcomers to Numpy, but with a bit of practice the rules become quite intuitive.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::broadcasting
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::broadcasting
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Broadcasting generally refers to how entries from the small array are “broadcast” to the larger array. The basic rule is as follows: first, suppose that two Numpy arrays <code>A</code> and <code>B</code> have the same number of dimensions (e.g., they are both 2D arrays). But suppose that along one of these dimensions <code>B</code> is only size 1. In that case, the the dimension of size 1 is <code>B</code> is automatically expanded (repeating all entries along that dimension), and then the operation between the two arrays is applied. Let’s look at a simple example:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Broadcasting generally refers to how entries from the small array are "broadcast" to the larger array.  The basic rule is as follows: first, suppose that two Numpy arrays `A` and `B` have the same number of dimensions (e.g., they are both 2D arrays).  But suppose that along one of these dimensions `B` is only size 1. In that case, the the dimension of size 1 is `B` is automatically expanded (repeating all entries along that dimension), and then the operation between the two arrays is applied.  Let's look at a simple example:
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::repeat
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::repeat
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">A <span class="op">=</span> np.ones((<span class="dv">4</span>,<span class="dv">3</span>))          <span class="co"># A is 4x3</span></a>
<a class="sourceLine" id="cb1-2" title="2">x <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]])      <span class="co"># x is 1x3</span></a>
<a class="sourceLine" id="cb1-3" title="3">A<span class="op">*</span>x                          <span class="co"># repeat x along dimension 4 (repeat four times), and add to A</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
A = np.ones((4,3))          # A is 4x3
x = np.array([[1,2,3]])      # x is 1x3
A*x                          # repeat x along dimension 4 (repeat four times), and add to A
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_58_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_57_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([[ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([[ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::effectively
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::effectively
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Effectively, the (1,3) array <code>x</code> (observer that it is actually a 2D array) is “resized” to (4,3), repeating its entries along the first dimension, and it is them multiplied elementwise by <code>A</code>. The effective result of this is that the columns of <code>A</code> are rescaled by the values of <code>x</code>. Note that no actual additional memory allocation happens, and the resize here is entirely from a conceptual perspective. Alternatively, the following code would rescale the <em>rows</em> of <code>A</code> by <code>x</code> (where here we need to construct a (4,1) sized array is order for the broadcasting to work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Effectively, the (1,3) array `x` (observer that it is actually a 2D array) is "resized" to (4,3), repeating its entries along the first dimension, and it is them multiplied elementwise by `A`.  The effective result of this is that the columns of `A` are rescaled by the values of `x`.  Note that no actual additional memory allocation happens, and the resize here is entirely from a conceptual perspective.  Alternatively, the following code would rescale the _rows_ of `A` by `x` (where here we need to construct a (4,1) sized array is order for the broadcasting to work.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_60_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_59_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">x <span class="op">=</span> np.array([[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>],[<span class="dv">4</span>]])</a>
<a class="sourceLine" id="cb1-2" title="2">A<span class="op">*</span>x</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
x = np.array([[1],[2],[3],[4]])
A*x
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_62_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_61_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([[ 1.,  1.,  1.],
       [ 2.,  2.,  2.],
       [ 3.,  3.,  3.],
       [ 4.,  4.,  4.]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([[ 1.,  1.,  1.],
       [ 2.,  2.,  2.],
       [ 3.,  3.,  3.],
       [ 4.,  4.,  4.]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::size
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::size
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Here <code>x</code> has size (4,1), so it is effectively resized to (4,3) along the second dimension, repeating values along the columns. This has the effect of scaling the rows of <code>A</code> by <code>x</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Here `x` has size (4,1), so it is effectively resized to (4,3) along the second dimension, repeating values along the columns.  This has the effect of scaling the rows of `A` by `x`.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::rule
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::rule
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>As a final note, the rule for numpy is that if the two arrays being operated upon have <em>different</em> numbers of dimensions, we extend the dimensions in the <em>leading</em> dimensions to all implicitly be 1. Thus, the following code will implicitly consider <code>x</code> (which is a 1D array of size 3), to be a (1,3) array, and then apply the broadcasting rules, which thus has the same effect as our first broadcasting example.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
As a final note, the rule for numpy is that if the two arrays being operated upon have _different_ numbers of dimensions, we extend the dimensions in the _leading_ dimensions to all implicitly be 1.  Thus, the following code will implicitly consider `x` (which is a 1D array of size 3), to be a (1,3) array, and then apply the broadcasting rules, which thus has the same effect as our first broadcasting example.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_64_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_63_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">x <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb1-2" title="2">A<span class="op">*</span>x</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
x = np.array([1,2,3])
A*x
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_66_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_65_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([[ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([[ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::implicitly
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::implicitly
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>If we want to implicitly “cast” a n sized 1D array to a (n,1) sized array, we can use the notation <code>x[:,None]</code> (we put “None” for the dimensions we want to define to be 1).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
If we want to implicitly "cast" a n sized 1D array to a (n,1) sized array, we can use the notation `x[:,None]` (we put "None" for the dimensions we want to define to be 1).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::none
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::none
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">x <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(x[:,<span class="va">None</span>], <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(A<span class="op">*</span>x[:,<span class="va">None</span>])</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
x = np.array([1,2,3,4])
print(x[:,None], "\n")
print(A*x[:,None])
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_68_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_67_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[1]
 [2]
 [3]
 [4]] 

[[ 1.  1.  1.]
 [ 2.  2.  2.]
 [ 3.  3.  3.]
 [ 4.  4.  4.]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[1]
 [2]
 [3]
 [4]] 

[[ 1.  1.  1.]
 [ 2.  2.  2.]
 [ 3.  3.  3.]
 [ 4.  4.  4.]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::rules
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::rules
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>These rules can be confusing, and it takes some time to get used to them, but the advantage of broadcasting is that you can compute many operations quite efficiently, and once you get used to the notation, it is actually not the difficult to understand what is happening. For example, from a “linear algebra” perspective, the right way to scale the column of a matrix is a matrix multiplication by a diagonal matrix, like in the following code.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
These rules can be confusing, and it takes some time to get used to them, but the advantage of broadcasting is that you can compute many operations quite efficiently, and once you get used to the notation, it is actually not the difficult to understand what is happening.  For example, from a "linear algebra" perspective, the right way to scale the column of a matrix is a matrix multiplication by a diagonal matrix, like in the following code.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_70_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_69_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">D <span class="op">=</span> np.diag(np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb1-2" title="2">A <span class="op">@</span> D</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
D = np.diag(np.array([1,2,3]))
A @ D
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_72_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_71_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([[ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([[ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.],
       [ 1.,  2.,  3.]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::cover
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::cover
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>(we will cover the matrix multiplication operator <code>@</code> in a moment). However, actually constructing the <code>np.diag()</code> matrix is wasteful: it explicitly constructs an <span class="math inline">\(n \times n\)</span> matrix that only has non-zero elements on the diagonal, then performs a dense matrix multiplication. It is much more efficient to simply scale <code>A</code> using the broadcasting method above, as no additional storage will be allocated, and the actual scaling operation only requires <span class="math inline">\(O(n^2)\)</span> time as opposed to the <span class="math inline">\(O(n^3)\)</span> time for a full matrix multiplication.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
(we will cover the matrix multiplication operator `@` in a moment).  However, actually constructing the `np.diag()` matrix is wasteful: it explicitly constructs an $n \times n$ matrix that only has non-zero elements on the diagonal, then performs a dense matrix multiplication.  It is much more efficient to simply scale `A` using the broadcasting method above, as no additional storage will be allocated, and the actual scaling operation only requires $O(n^2)$ time as opposed to the $O(n^3)$ time for a full matrix multiplication.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Linear algebra operations
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Linear algebra operations
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::linear
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::starting
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::starting
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Starting with Python 3, there is now a matrix multiplication operator <code>@</code> defined between numpy arrays (previously one had to use the more cumbersome <code>np.dot()</code> function to accomplish the same thing). Note that in the following example, all the array sizes are created such that the matrix multiplications work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Starting with Python 3, there is now a matrix multiplication operator `@` defined between numpy arrays (previously one had to use the more cumbersome `np.dot()` function to accomplish the same thing).  Note that in the following example, all the array sizes are created such that the matrix multiplications work.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::random
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::random
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">A <span class="op">=</span> np.random.randn(<span class="dv">5</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-2" title="2">C <span class="op">=</span> np.random.randn(<span class="dv">4</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-3" title="3">x <span class="op">=</span> np.random.randn(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">y <span class="op">=</span> np.random.randn(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb1-5" title="5">z <span class="op">=</span> np.random.randn(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="bu">print</span>(A <span class="op">@</span> C, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)       <span class="co"># matrix-matrix multiply (returns 2D array)</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="bu">print</span>(A <span class="op">@</span> x, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)       <span class="co"># matrix-vector multiply (returns 1D array)</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="bu">print</span>(x <span class="op">@</span> z)       <span class="co"># inner product (scalar)</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
A = np.random.randn(5,4)
C = np.random.randn(4,3)
x = np.random.randn(4)
y = np.random.randn(5)
z = np.random.randn(4)

print(A @ C, "\n")       # matrix-matrix multiply (returns 2D array)
print(A @ x, "\n")       # matrix-vector multiply (returns 1D array)
print(x @ z)       # inner product (scalar)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::-2
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::-2
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[-2.349365    0.31307737  0.43701076]
 [-3.01521936  2.33512524 -0.59099322]
 [-0.02346425  0.0118288  -2.68179453]
 [ 0.58286024 -1.36334426  0.35011801]
 [ 0.56680928 -1.83411679  1.29601818]] 

[-0.19595591  0.22193364  0.88633042  0.40914083 -0.87358333] 

1.11337305084
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[-2.349365    0.31307737  0.43701076]
 [-3.01521936  2.33512524 -0.59099322]
 [-0.02346425  0.0118288  -2.68179453]
 [ 0.58286024 -1.36334426  0.35011801]
 [ 0.56680928 -1.83411679  1.29601818]] 

[-0.19595591  0.22193364  0.88633042  0.40914083 -0.87358333] 

1.11337305084
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::point
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::point
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>There is an important point to note, though, here. Depending on the sizes of the arrays passed to the <code>@</code> operator, numpy will return results of different sizes: two 2D arrays result in a 2D array (matrix-matrix product), a 2D array and a 1D array result in a 1D array (matrix-vector product), and two 1D arrays result in a scalar (just a floating point number, not an <code>ndarray</code> at all). This can cause some issues if, for instance, your code always assumes that the result of a <code>@</code> operation between two <code>ndarray</code> objects will also return an <code>ndarray</code>: depending on the size of the arrays you pass (i.e., if they are both 1D arrays), you will actually get a floating point object, not an <code>ndarray</code> at all.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
There is an important point to note, though, here. Depending on the sizes of the arrays passed to the `@` operator, numpy will return results of different sizes: two 2D arrays result in a 2D array (matrix-matrix product), a 2D array and a 1D array result in a 1D array (matrix-vector product), and two 1D arrays result in a scalar (just a floating point number, not an `ndarray` at all).  This can cause some issues if, for instance, your code always assumes that the result of a `@` operation between two `ndarray` objects will also return an `ndarray`: depending on the size of the arrays you pass (i.e., if they are both 1D arrays), you will actually get a floating point object, not an `ndarray` at all.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::especially
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::especially
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The rules can be especially confusing when we think about multiplying vectors on the left of matrices, i.e., forming a matrix-vector product <span class="math inline">\(y^T A\)</span> for <span class="math inline">\(y \in \mathbb{R}^m\)</span>, <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span>. This is a valid matrix product, but since Numpy has no distinction between column and row vectors, both the following operations compute the same 1D result (i.e., which performs the above left-multplication, but return the result just as a 1D array):</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The rules can be especially confusing when we think about multiplying vectors on the left of matrices, i.e., forming a matrix-vector product $y^T A$ for $y \in \mathbb{R}^m$, $A \in \mathbb{R}^{m \times n}$.  This is a valid matrix product, but since Numpy has no distinction between column and row vectors, both the following operations compute the same 1D result (i.e., which performs the above left-multplication, but return the result just as a 1D array):
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_74_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_73_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A.T <span class="op">@</span> y, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(y.T <span class="op">@</span> A)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A.T @ y, "\n")
print(y.T @ A)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_76_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_75_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[-0.20969054  1.62940281 -0.89696956 -2.29205352] 

[-0.20969054  1.62940281 -0.89696956 -2.29205352]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[-0.20969054  1.62940281 -0.89696956 -2.29205352] 

[-0.20969054  1.62940281 -0.89696956 -2.29205352]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::confusing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::confusing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The confusing part is that because transposes have no meaning to for 1D arrays, the following code <em>also</em> returns the same result, despite <span class="math inline">\(y A\)</span> not being a valid linear algebra expression.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The confusing part is that because transposes have no meaning to for 1D arrays, the following code _also_ returns the same result, despite $y A$ not being a valid linear algebra expression.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_78_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_77_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(y <span class="op">@</span> A)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(y @ A)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_80_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_79_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[-0.20969054  1.62940281 -0.89696956 -2.29205352]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[-0.20969054  1.62940281 -0.89696956 -2.29205352]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::hand
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::hand
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>On the other hand, trying to do the multiplication in the other order <span class="math inline">\(Ay\)</span> (which is also not a valid linear algebra expression), does throw an error.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
On the other hand, trying to do the multiplication in the other order $Ay$ (which is also not a valid linear algebra expression), does throw an error.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_82_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_81_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A <span class="op">@</span> y)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A @ y)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::oddities
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::oddities
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>These are oddities that you will get used to, and while I initially thought that the notation for everything here was rather counter-intuitive, it actually does make sense (in some respect) why everything was implemented this way.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
These are oddities that you will get used to, and while I initially thought that the notation for everything here was rather counter-intuitive, it actually does make sense (in some respect) why everything was implemented this way.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::attempt
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::attempt
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Note</strong>: in an attempt to “fix” these problems, the Numpy library also contains an <code>np.matrix</code> class (where everything is represented as a 2D matrix, with row and column vectors explicit, and the multiplication operator <code>*</code> overloaded to perform matrix multiplication). Don’t use this class. The issue is that 1) when you want to perform <em>non-matrix</em> operations, you need to cast them back to <code>np.ndarray</code> objects, which creates very cumbersome code; and 2) most function and external libraries return <code>ndarray</code> objects anyway. There are, somewhat annoyingly, some collection of Numpy functions (and especially Scipy functions) that <em>do</em> return <code>np.matrix</code> objects, and the one function you’ll need to know is <code>np.asarray()</code>, which casts them back to arrays while not performing any matrix copies. For example, the sparse matrix routines that we will see shortly have a function <code>.todense()</code> that returns dense version of the matrix but as an <code>np.matrix</code> object.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Note**: in an attempt to "fix" these problems, the Numpy library also contains an `np.matrix` class (where everything is represented as a 2D matrix, with row and column vectors explicit, and the multiplication operator `*` overloaded to perform matrix multiplication).  Don't use this class.  The issue is that 1) when you want to perform _non-matrix_ operations, you need to cast them back to `np.ndarray` objects, which creates very cumbersome code; and 2) most function and external libraries return `ndarray` objects anyway.  There are, somewhat annoyingly, some collection of Numpy functions (and especially Scipy functions) that _do_ return `np.matrix` objects, and the one function you'll need to know is `np.asarray()`, which casts them back to arrays while not performing any matrix copies.  For example, the sparse matrix routines that we will see shortly have a function `.todense()` that returns dense version of the matrix but as an `np.matrix` object.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::import
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::import
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">import</span> scipy.sparse <span class="im">as</span> sp</a>
<a class="sourceLine" id="cb1-2" title="2">A <span class="op">=</span> sp.coo_matrix(np.eye(<span class="dv">5</span>))</a>
<a class="sourceLine" id="cb1-3" title="3">A.todense()</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
import scipy.sparse as sp
A = sp.coo_matrix(np.eye(5))
A.todense()
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_84_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_83_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
matrix([[ 1.,  0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.,  0.],
        [ 0.,  0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  1.,  0.],
        [ 0.,  0.,  0.,  0.,  1.]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
matrix([[ 1.,  0.,  0.,  0.,  0.],
        [ 0.,  1.,  0.,  0.,  0.],
        [ 0.,  0.,  1.,  0.,  0.],
        [ 0.,  0.,  0.,  1.,  0.],
        [ 0.,  0.,  0.,  0.,  1.]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::cast
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::cast
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>You can cast it to an <code>ndarray</code> using the code.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You can cast it to an `ndarray` using the code.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::asarray
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::asarray
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">np.asarray(A.todense())</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
np.asarray(A.todense())
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_86_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_85_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  1.]])
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  1.]])
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Order of matrix multiplication operators
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Order of matrix multiplication operators
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::order
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::look
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::look
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s also look at what we mentioned above, considering the order of matrix multiplications in terms of time complexity. By default the <code>@</code> operator will be applied left-to-right, which may result is very inefficient orders for the matrix multiplication.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's also look at what we mentioned above, considering the order of matrix multiplications in terms of time complexity.  By default the `@` operator will be applied left-to-right, which may result is very inefficient orders for the matrix multiplication.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::randn
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::randn
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">A <span class="op">=</span> np.random.randn(<span class="dv">1000</span>,<span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb1-2" title="2">B <span class="op">=</span> np.random.randn(<span class="dv">1000</span>,<span class="dv">2000</span>)</a>
<a class="sourceLine" id="cb1-3" title="3">x <span class="op">=</span> np.random.randn(<span class="dv">2000</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">%</span>timeit A <span class="op">@</span> B <span class="op">@</span> x</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
A = np.random.randn(1000,1000)
B = np.random.randn(1000,2000)
x = np.random.randn(2000)
%timeit A @ B @ x
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::loop
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::loop
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
67.9 ms ± 3.91 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
67.9 ms ± 3.91 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::performs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::performs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This performs the matrix products <span class="math inline">\((AB)x\)</span>, which computes the inefficient matrix multiplication first. If we want to compute the product in the much more efficient order <span class="math inline">\(A(Bx)\)</span>, we would use the command</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This performs the matrix products $(AB)x$, which computes the inefficient matrix multiplication first.  If we want to compute the product in the much more efficient order $A(Bx)$, we would use the command
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_88_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_87_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="op">%</span>timeit A <span class="op">@</span> (B <span class="op">@</span> x)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
%timeit A @ (B @ x)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::mean
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::mean
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
1.44 ms ± 73.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
1.44 ms ± 73.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::operation
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::operation
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The later operation can be about 50x faster that the first version, and the difference only gets larger for larger matrices. Be <em>very</em> careful about this point when you are multiplying big matrices and vectors together.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The later operation can be about 50x faster that the first version, and the difference only gets larger for larger matrices.  Be _very_ careful about this point when you are multiplying big matrices and vectors together.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Inverses and linear solves
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Inverses and linear solves
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::inverses
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::includes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::includes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Finally, Numpy includes the routine <code>np.linalg.inv()</code> for computing the matrix inverse <span class="math inline">\(A^{-1}\)</span> and <code>np.linalg.solve()</code> for computing the matrix solve <span class="math inline">\(A^{-1}b\)</span>, for <span class="math inline">\(A \in \mathbb{R}^{n \times n}\)</span>, <span class="math inline">\(b \in \mathbb{R}^n\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Finally, Numpy includes the routine `np.linalg.inv()` for computing the matrix inverse $A^{-1}$ and `np.linalg.solve()` for computing the matrix solve $A^{-1}b$, for $A \in \mathbb{R}^{n \times n}$, $b \in \mathbb{R}^n$.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::linalg
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::linalg
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">b <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">13</span>,<span class="dv">9</span>])</a>
<a class="sourceLine" id="cb1-2" title="2">A <span class="op">=</span> np.array([[<span class="dv">4</span>,<span class="op">-</span><span class="dv">5</span>], [<span class="op">-</span><span class="dv">2</span>,<span class="dv">3</span>]])</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="bu">print</span>(np.linalg.inv(A), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)   <span class="co"># explicitly form inverse</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="bu">print</span>(np.linalg.solve(A,b))     <span class="co"># compute solution A^{-1}b</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
b = np.array([-13,9])
A = np.array([[4,-5], [-2,3]])

print(np.linalg.inv(A), "\n")   # explicitly form inverse
print(np.linalg.solve(A,b))     # compute solution A^{-1}b
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_90_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_89_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[ 1.5  2.5]
 [ 1.   2. ]] 

[ 3.  5.]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[ 1.5  2.5]
 [ 1.   2. ]] 

[ 3.  5.]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::obviously
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::obviously
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Obviously the <code>np.linalg.solve()</code> routine is also equivalent to the matrix-vector product with the inverse.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Obviously the `np.linalg.solve()` routine is also equivalent to the matrix-vector product with the inverse.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::inv
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::inv
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(np.linalg.inv(A) <span class="op">@</span> b)    <span class="co"># don&#39;t do this</span></a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(np.linalg.inv(A) @ b)    # don't do this
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_92_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_91_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[ 3.  5.]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[ 3.  5.]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::general
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::general
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>However, you should <em>not</em> do this. In general, actually computing the inverse and then multiplying by a vector is both slower and less numerically stable than just solving the linear system. For those who are curious (you won’t need to know this for this class, but it can be useful to understand), this is because performing the solve internally actually computes a <em>factorization</em> of the matrix called the LU factorization: it decomposes <span class="math inline">\(A\)</span> into the matrix product <span class="math inline">\(A = LU\)</span> where <span class="math inline">\(L\)</span> is a lower triangular matrix (all entries above the diagonal are zero), and <span class="math inline">\(U\)</span> is an upper triangular matrix (all entries below the diagonal are zero); if we want to be even more precise it actually computes the LU factorization on a version of <span class="math inline">\(A\)</span> with permuted rows and columns, but that is definitely beyond the scope of this course. After factorizing <span class="math inline">\(A\)</span> in this manner, it computes the inverse</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
However, you should _not_ do this.  In general, actually computing the inverse and then multiplying by a vector is both slower and less numerically stable than just solving the linear system.  For those who are curious (you won't need to know this for this class, but it can be useful to understand), this is because performing the solve internally actually computes a _factorization_ of the matrix called the LU factorization: it decomposes $A$ into the matrix product $A = LU$ where $L$ is a lower triangular matrix (all entries above the diagonal are zero), and $U$ is an upper triangular matrix (all entries below the diagonal are zero); if we want to be even more precise it actually computes the LU factorization on a version of $A$ with permuted rows and columns, but that is definitely beyond the scope of this course.  After factorizing $A$ in this manner, it computes the inverse
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_94_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_93_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A^{-1} b = (L U)^{-1} b = U^{-1} L^{-1} b
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A^{-1} b = (L U)^{-1} b = U^{-1} L^{-1} b
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::computing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::computing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In turns out that computing the product <span class="math inline">\(L^{-1} b\)</span> (again, not actually explicitly computing the inverse of <span class="math inline">\(A\)</span>, just computing the solve) for a triangular matrix is very efficient, it just takes <span class="math inline">\(O(n^2)\)</span> operations instead of <span class="math inline">\(O(n^3)\)</span> operations as for a generic matrix. This means that once we compute the factorization <span class="math inline">\(A = LU\)</span> (which does itself take <span class="math inline">\(O(n^3)\)</span> time, as a note, which is why matrix solves are <span class="math inline">\(O(n^3)\)</span> complexity), solving for the right hand size <span class="math inline">\(b\)</span> is “easy”.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In turns out that computing the product $L^{-1} b$ (again, not actually explicitly computing the inverse of $A$, just computing the solve) for a triangular matrix is very efficient, it just takes $O(n^2)$ operations instead of $O(n^3)$ operations as for a generic matrix.  This means that once we compute the factorization $A = LU$ (which does itself take $O(n^3)$ time, as a note, which is why matrix solves are $O(n^3)$ complexity), solving for the right hand size $b$ is "easy".
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::compute
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::compute
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In fact the way that we compute the inverse is by first computing the LU factorization and then “solving” for the right hand side <span class="math inline">\(I\)</span>. But obviously if we just want to ultimately solve for a single right hand size <span class="math inline">\(b\)</span>, this is an unnecessary step, and it introduces additional error into the computation. For this reason, you will almost ways prefer to use <code>np.linalg.solve()</code> unless to really need elements of the inverse itself (and not just to multiply the inverse by some expression).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In fact the way that we compute the inverse is by first computing the LU factorization and then "solving" for the right hand side $I$.  But obviously if we just want to ultimately solve for a single right hand size $b$, this is an unnecessary step, and it introduces additional error into the computation.  For this reason, you will almost ways prefer to use `np.linalg.solve()` unless to really need elements of the inverse itself (and not just to multiply the inverse by some expression).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Sparse matrices
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Sparse matrices
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::topic
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::topic
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::topic
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The last topic we will touch on, which at our level of discussion will relate more to the representation of matrices than the linear algebra behind it, is the concept of sparse matrices. Many problems in data science deal with matrix representations that are inherently <em>sparse</em> (that is, they contain a majority of zero elements, with only a few non-zeros). For example, in the two forthcoming lectures, we will discuss graphs and free text modeling. As we will see, a primary method for representing graphs will be the adjacency matrix, a matrix that has as a non-zero element in location <span class="math inline">\(i,j\)</span> if there is an edge between node <span class="math inline">\(i\)</span> and node <span class="math inline">\(j\)</span>; many natural graphs have only a small number of nodes connected to each other, so the resulting adjacency matrix is sparse. Similarly, in free text modeling it is common to represent documents via a “bag of words” model, where we represent each document as a large vector that that indicates which words occur in the document; since typical documents only contain a small fraction of all possible words, this “word-document co-occurrence” matrix is usually sparse.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The last topic we will touch on, which at our level of discussion will relate more to the representation of matrices than the linear algebra behind it, is the concept of sparse matrices.  Many problems in data science deal with matrix representations that are inherently _sparse_ (that is, they contain a majority of zero elements, with only a few non-zeros).  For example, in the two forthcoming lectures, we will discuss graphs and free text modeling.  As we will see, a primary method for representing graphs will be the adjacency matrix, a matrix that has as a non-zero element in location $i,j$ if there is an edge between node $i$ and node $j$; many natural graphs have only a small number of nodes connected to each other, so the resulting adjacency matrix is sparse.  Similarly, in free text modeling it is common to represent documents via a "bag of words" model, where we represent each document as a large vector that that indicates which words occur in the document; since typical documents only contain a small fraction of all possible words, this "word-document co-occurrence" matrix is usually sparse.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::course
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::course
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>While of course it is possible to represent a sparse matrix using the standard dense format specified above, doing so is quite wasteful from both a space and time complexity standpoint; explicitly representing (and multiplying by) many zeros is both a waste of memory and computation. Because of this, when matrices have a significant number of zero entries, it makes sense that we should somehow exploit this fact to reduce memory consumption and speed up computation. Fortunately, there are a large collection of sparse matrix libraries that accomplish these goals exactly. While we of course won’t have the ability to go into how these libraries work in any real detail (especially for the more complex operations like sparse matrix-matrix multiplies (already hard enough of a problem to do “easily”) let alone more complex operations like sparse matrix factorizations (where there is a whole subfield dedicated to such algorithms). The good news, though, is that from a pure mathematical standpoint, sparse matrices naturally behave just like dense matrices (matrix multiplication, inversion, etc, all have the same syntax); really, these are fundamentally a <em>computational</em> tool, and with a slight understanding of how sparse matrices function, you can make fairly good use of the libraries even if you don’t initially know all the details behind the algorithms.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
While of course it is possible to represent a sparse matrix using the standard dense format specified above, doing so is quite wasteful from both a space and time complexity standpoint; explicitly representing (and multiplying by) many zeros is both a waste of memory and computation.  Because of this, when matrices have a significant number of zero entries, it makes sense that we should somehow exploit this fact to reduce memory consumption and speed up computation.  Fortunately, there are a large collection of sparse matrix libraries that accomplish these goals exactly.  While we of course won't have the ability to go into how these libraries work in any real detail (especially for the more complex operations like sparse matrix-matrix multiplies (already hard enough of a problem to do "easily") let alone more complex operations like sparse matrix factorizations (where there is a whole subfield dedicated to such algorithms).  The good news, though, is that from a pure mathematical standpoint, sparse matrices naturally behave just like dense matrices (matrix multiplication, inversion, etc, all have the same syntax); really, these are fundamentally a _computational_ tool, and with a slight understanding of how sparse matrices function, you can make fairly good use of the libraries even if you don't initially know all the details behind the algorithms.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Sparse data formats
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Sparse data formats
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::sparse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::primary
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::primary
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The first and primary element we will highlight is the <em>data formats</em> used to specify sparse matrices. Unlike dense matrices, where there is a natural way to represent elements in memory (though even there we had the column-major/row-major choice), there are many different ways we can represent sparse matrices, and different approaches are better suited to different tasks. Understanding these formats is a starting point to learning to use sparse matrix libraries, and will also draw connections to later topics we discuss. In these notes we will cover two of the most common formats you’ll encounter: the coordinate (COO) format, and the compressed sparse column (CSC) format. Most other formats have some similarity to these, so they serve as a good starting point to understanding sparse matrices.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The first and primary element we will highlight is the _data formats_ used to specify sparse matrices.  Unlike dense matrices, where there is a natural way to represent elements in memory (though even there we had the column-major/row-major choice), there are many different ways we can represent sparse matrices, and different approaches are better suited to different tasks.  Understanding these formats is a starting point to learning to use sparse matrix libraries, and will also draw connections to later topics we discuss.  In these notes we will cover two of the most common formats you'll encounter: the coordinate (COO) format, and the compressed sparse column (CSC) format.  Most other formats have some similarity to these, so they serve as a good starting point to understanding sparse matrices.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::coordinate
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::coordinate
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Coordinate (COO) format.</strong> Perhaps the most natural way to express a sparse matrix is by a “list” of (row, column, value) tuples; because we know that only very few locations will actually have non-zero entries, this format lets us just express the entries that exist, where all other entries that are not specified are assumed to be zero. This is in fact essentially exactly the intuition behind the coordinate (commonly abbreviated COO, despite the fact that it is not an acronym) format for sparse matrices. In coo format, we use three 1D arrays to specify a matrix, a <code>row_indices</code> array, a <code>col_indices</code> array, and a <code>values</code> array. These contain exactly what you would expect. For each non-zero entry in the matrix is there a corresponding element in these vectors that specifies the row, column, and value of that matrix. Let’s consider the example matrix</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Coordinate (COO) format.** Perhaps the most natural way to express a sparse matrix is by a "list" of (row, column, value) tuples; because we know that only very few locations will actually have non-zero entries, this format lets us just express the entries that exist, where all other entries that are not specified are assumed to be zero.  This is in fact essentially exactly the intuition behind the coordinate (commonly abbreviated COO, despite the fact that it is not an acronym) format for sparse matrices.  In coo format, we use three 1D arrays to specify a matrix, a `row_indices` array, a `col_indices` array, and a `values` array.  These contain exactly what you would expect.  For each non-zero entry in the matrix is there a corresponding element in these vectors that specifies the row, column, and value of that matrix.  Let's consider the example matrix
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_96_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_95_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[
A \in \mathbb{R}^{4\times 4} = \left [ \begin{array}{cccc}
0 &amp; 0 &amp; 3 &amp; 0 \\
2 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
4 &amp; 0 &amp; 1 &amp; 0
\end{array} \right ].
\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
$$
A \in \mathbb{R}^{4\times 4} = \left [ \begin{array}{cccc}
0 & 0 & 3 & 0 \\
2 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 \\
4 & 0 & 1 & 0
\end{array} \right ].
$$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::representation
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::representation
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A COO representation of this matrix could be (this is just specifying generic arrays, not in any particular language):</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A COO representation of this matrix could be (this is just specifying generic arrays, not in any particular language):
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::values
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::values
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">values <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-2" title="2">row_indices <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-3" title="3">column_indices <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
values = [2, 4, 1, 3, 1, 1]
row_indices = [1, 3, 2, 0, 3, 1]
column_indices = [0, 0, 1, 2, 2, 3]
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::although
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::although
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Although here we ordered the entries in these arrays in a “column-major” fashion, COO format has no such requirements: we could specify the elements of the matrix in any order we desire (and even have duplicate entires, where the true value is assumed to be the sum of all entries correspond to a particular row and column). The size of all these entries will be equal to the number of nonzeros in <code>A</code>, a number which will refer to as <span class="math inline">\(\mathrm{nnz}\)</span> when we need to use it notationally. Finally, not that in addition to the entries in the above matrices, we would also need to store the actual size of the array (number of rows <span class="math inline">\(m\)</span> and columns <span class="math inline">\(n\)</span> respectively), to cover the case where we have additional rows/columns of all zeros.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Although here we ordered the entries in these arrays in a "column-major" fashion, COO format has no such requirements: we could specify the elements of the matrix in any order we desire (and even have duplicate entires, where the true value is assumed to be the sum of all entries correspond to a particular row and column).  The size of all these entries will be equal to the number of nonzeros in `A`, a number which will refer to as $\mathrm{nnz}$ when we need to use it notationally.  Finally, not that in addition to the entries in the above matrices, we would also need to store the actual size of the array (number of rows $m$ and columns $n$ respectively), to cover the  case where we have additional rows/columns of all zeros.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::advantage
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::advantage
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The advantage of the COO format is that it is good for constructing sparse matrices; because items can be stored in any order to add a new element the matrix, we simply append an entry to the arrays (depending on how these arrays are stored, you would typically “pre-allocate” a bit of extra storage, resizing the arrays as needed, just like Python does with its lists, if you expect to be frequently adding elements). On the flipside, it is quite back for <em>inspecting</em> sparse matrices. Suppose we wanted to look up the value <code>A[i,j]</code> in a sparse matrix in COO format. Because elements can be in any order, we would have no option but to perform a linear scan through the entire arrays, to see if any row/column pair matched <code>i</code>/<code>j</code>, with complexity <span class="math inline">\(O(n)\)</span> (where here say that the matrix is <span class="math inline">\(n \times n\)</span>).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The advantage of the COO format is that it is good for constructing sparse matrices; because items can be stored in any order to add a new element the matrix, we simply append an entry to the arrays (depending on how these arrays are stored, you would typically "pre-allocate" a bit of extra storage, resizing the arrays as needed, just like Python does with its lists, if you expect to be frequently adding elements).  On the flipside, it is quite back for _inspecting_ sparse matrices.  Suppose we wanted to look up the value `A[i,j]` in a sparse matrix in COO format.  Because elements can be in any order, we would have no option but to perform a linear scan through the entire arrays, to see if any row/column pair matched `i`/`j`, with complexity $O(n)$ (where here say that the matrix is $n \times n$).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::format
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::format
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>If the matrix in COO format was always maintained in column-major order, as described above, then this complexity could be reduced to <span class="math inline">\(O(\log n)\)</span> via binary search on the column indices; however, maintaining it in this order would also remove our ability to easily add new elements to matrix, because we would need to shift items in the various arrays (i.e., by copying the memory to a later location) whenever a new element was added. And if we’re willing to make this sacrifice, it turns out there is a better way to store the matrix, described next.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
If the matrix in COO format was always maintained in column-major order, as described above, then this complexity could be reduced to $O(\log n)$ via binary search on the column indices; however, maintaining it in this order would also remove our ability to easily add new elements to matrix, because we would need to shift items in the various arrays (i.e., by copying the memory to a later location) whenever a new element was added.  And if we're willing to make this sacrifice, it turns out there is a better way to store the matrix, described next.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::compressed
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::compressed
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><strong>Compressed sparse column (CSC) format.</strong> The downsides of the above approach motivate a different matrix storage, where we <em>do</em> explicitly maintain a column-major ordering of the non-zero entries. However, if we are going to do so, then it turns out we actually get a more efficient structure if we change the nature of the <code>column_indices</code> array. Instead of an <span class="math inline">\(\mathrm{nnz}\)</span>-dimensional array containing the column index of each entry, we make the array be a <span class="math inline">\((n+1)\)</span>-dimenional array (remember that <span class="math inline">\(n\)</span> is the number of columns in the matrix), pointing to the <em>index</em> of the starting location for each column in the <code>row_indices</code> and <code>values</code> array.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
**Compressed sparse column (CSC) format.** The downsides of the above approach motivate a different matrix storage, where we _do_ explicitly maintain a column-major ordering of the non-zero entries.  However, if we are going to do so, then it turns out we actually get a more efficient structure if we change the nature of the `column_indices` array.  Instead of an $\mathrm{nnz}$-dimensional array containing the column index of each entry, we make the array be a $(n+1)$-dimenional array (remember that $n$ is the number of columns in the matrix), pointing to the _index_ of the starting location for each column in the `row_indices` and `values` array.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::hard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::hard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This is a bit hard to understand at first, so an example can make things more understandable. Instead of the COO format above, the CSC format consists of the arrays</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This is a bit hard to understand at first, so an example can make things more understandable.  Instead of the COO format above, the CSC format consists of the arrays
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::indices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::indices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">values <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-2" title="2">row_indices <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-3" title="3">column_indices <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>]</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
values = [2, 4, 1, 3, 1, 1]
row_indices = [1, 3, 2, 0, 3, 1]
column_indices = [0, 2, 3, 5, 6]
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::unpack
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::unpack
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s unpack this a bit. The fact that <code>column_indices</code> has a 5 in element 3 (remember, we are assuming zero indexing), means that the index-3 column (really the forth column) starts at index 5 in the <code>row_indices</code> and <code>values</code> arrays; the fact that <code>column_indices</code> has a 2 in element 1 means that the index-1 column (really the second column) starts at index 2 in the <code>row_indices</code> and <code>values</code> arrays.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's unpack this a bit.  The fact that `column_indices` has a 5 in element 3 (remember, we are assuming zero indexing), means that the index-3 column (really the forth column) starts at index 5 in the `row_indices` and `values` arrays; the fact that `column_indices` has a 2 in element 1 means that the index-1 column (really the second column) starts at index 2 in the `row_indices` and `values` arrays.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::extremely
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::extremely
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The advantage to this format is that it is extremely efficient to look up <em>all</em> the entries in a given column <span class="math inline">\(i\)</span>. If we want to know the entries of column <code>i</code>, we would use simply get the slice (using Python notation here)</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The advantage to this format is that it is extremely efficient to look up _all_ the entries in a given column $i$.  If we want to know the entries of column `i`, we would use simply get the slice (using Python notation here)
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_98_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_97_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">values[column_indices[i]:column_indices[i<span class="op">+</span><span class="dv">1</span>]]</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
values[column_indices[i]:column_indices[i+1]]
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::could
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::could
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>(the same could be done to get the row indices). This also hopefully clarifies why the <code>column_indices</code> array contains <span class="math inline">\(n+1\)</span> entries: so that we can always use the range <code>column_indices[i]:column_indices[i+1]</code> to get all the items in the column (the last entry in <code>column_indices</code> must therefore be equal to the number of non-zero elements in the matrix.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
(the same could be done to get the row indices).  This also hopefully clarifies why the `column_indices` array contains $n+1$ entries: so that we can always use the range `column_indices[i]:column_indices[i+1]` to get all the items in the column (the last entry in `column_indices` must therefore be equal to the number of non-zero elements in the matrix.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::apparent
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::apparent
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>As is hopefully apparent, CSC format is typically much better than COO for quickly accessing elements, especially accessing single rows in the matrix (there is a corresponding compressed sparse row (CSR) that does the exact same thing but row-wise, for quick access to rows). But conversely, it is very poor at adding new elements to the array (this requires shifting all subsequent items in the <code>row_indices</code> and <code>values</code> columns, and incrementing subsequent elements in the <code>column_indices</code> array).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
As is hopefully apparent, CSC format is typically much better than COO for quickly accessing elements, especially accessing single rows in the matrix (there is a corresponding compressed sparse row (CSR) that does the exact same thing but row-wise, for quick access to rows).  But conversely, it is very poor at adding new elements to the array (this requires shifting all subsequent items in the `row_indices` and `values` columns, and incrementing subsequent elements in the `column_indices` array).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Basics of sparse matrix computation
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Basics of sparse matrix computation
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::matrix
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::discussion
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::discussion
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The above discussion hopefully makes it fairly obvious why sparse matrices are a good idea from a storage standpoint: instead of storing <span class="math inline">\(mn\)</span> elements for an <span class="math inline">\(m \times n\)</span>, we can store <span class="math inline">\(3\cdot\mathrm{nnz}\)</span> arrays (we ignore storing <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, because you actually need to do this for both sparse and dense matrices anyway) for COO format, or <span class="math inline">\(2\cdot\mathrm{nnz} + n + 1\)</span> elements for CSC format.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The above discussion hopefully makes it fairly obvious why sparse matrices are a good idea from a storage standpoint: instead of storing $mn$ elements for an $m \times n$, we can store $3\cdot\mathrm{nnz}$ arrays (we ignore storing $m$ and $n$, because you actually need to do this for both sparse and dense matrices anyway) for COO format, or $2\cdot\mathrm{nnz} + n + 1$ elements for CSC format.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::sparse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::sparse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>But why are sparse matrices also more computationally efficient. To give a brief sense of this, let’s consider one of the most ubiquitous operations in linear algebra, the product of a (dense or sparse) matrix with a (dense) vector <span class="math inline">\(Ax\)</span> for <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span>, <span class="math inline">\(x \in \mathbb{R}^n\)</span>. This operation will be <span class="math inline">\(O(mn)\)</span> if we represent <span class="math inline">\(A\)</span> densely (this follows immediately from the definition of the matrix-vector product). But what about if we represent <span class="math inline">\(A\)</span> COO sparse format. In this case, the algorithm for matrix-vector products is fairly simple</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
But why are sparse matrices also more computationally efficient.  To give a brief sense of this, let's consider one of the most ubiquitous operations in linear algebra, the product of a (dense or sparse) matrix with a (dense) vector $Ax$ for $A \in \mathbb{R}^{m \times n}$, $x \in \mathbb{R}^n$.  This operation will be $O(mn)$ if we represent $A$ densely (this follows immediately from the definition of the matrix-vector product).  But what about if we represent $A$ COO sparse format.  In this case, the algorithm for matrix-vector products is fairly simple
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::initialize
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::initialize
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<ol type="1">
<li>Initialize <span class="math inline">\(y = 0\)</span></li>
<li>For each <span class="math inline">\((i,j,v)\)</span> in <span class="math inline">\(A\)</span>:
<ul>
<li>Set <span class="math inline">\(y_i := y_i + x_j \cdot v\)</span></li>
</ul></li>
</ol>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
1. Initialize $y = 0$
2. For each $(i,j,v)$ in $A$:
    * Set $y_i := y_i + x_j \cdot v$
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::running
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::running
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>After running the algorithm, <span class="math inline">\(y = Ax\)</span>, as this is exactly equivalent to the traditional definition of matrix-vector products, we are just accumulating the sum for each individual tuple in <span class="math inline">\(A\)</span> represented in COO form (if the above algorithm isn’t apparent to you, try to derive it directly from the definition of the COO format and the definition of matrix multiplication above). Beacuse this algorithm obviously only loops over the non-zero entries of <span class="math inline">\(A\)</span> once, it rquires only <span class="math inline">\(O(\mathrm{nnz})\)</span> operations, a potentially significant reduction.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
After running the algorithm, $y = Ax$, as this is exactly equivalent to the traditional definition of matrix-vector products, we are just accumulating the sum for each individual tuple in $A$ represented in COO form (if the above algorithm isn't apparent to you, try to derive it directly from the definition of the COO format and the definition of matrix multiplication above).  Beacuse this algorithm obviously only loops over the non-zero entries of $A$ once, it rquires only $O(\mathrm{nnz})$ operations, a potentially significant reduction.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::write
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::write
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can also write a similar routine for matrices in CSC format, though we leave that out here for simplicit. As a general rule of thumb, you should use sparse matrices for matrix-vector multiplication if your matrix is 80% zero or (there due to the 2-3x more storage needed, and the fact that the matrix-vector products are usually a little less cache efficient than purely dense operations). If your operations involve matrix solves, then a better rule of this is that you need 95% sparsity or more (operations related to matrix solves actually decrease sparsity of the intermediate components we compute). This last rule of thumb, though, actually depends on the precise sparsity pattern of the data (if the sparsity is truly random, it woudl actually require much higher degrees of sparsity to make matrix sovles worth it, but for reasons we won’t go into, many “realstic” matrices have structure that makes the sparse solve more efficient than the worst case.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can also write a similar routine for matrices in CSC format, though we leave that out here for simplicit. As a general rule of thumb, you should use sparse matrices for matrix-vector multiplication if your matrix is 80% zero or (there due to the 2-3x more storage needed, and the fact that the matrix-vector products are usually a little less cache efficient than purely dense operations).  If your operations involve matrix solves, then a better rule of this is that you need 95% sparsity or more (operations related to matrix solves actually decrease sparsity of the intermediate components we compute).  This last rule of thumb, though, actually depends on the precise sparsity pattern of the data (if the sparsity is truly random, it woudl actually require much higher degrees of sparsity to make matrix sovles worth it, but for reasons we won't go into, many "realstic" matrices have structure that makes the sparse solve more efficient than the worst case.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Python sparse matrix libraries
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Python sparse matrix libraries
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::python
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::standard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::standard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The standard library for manipulating sparse matrices with Python is the <a href="https://docs.scipy.org/doc/scipy/reference/sparse.html">scipy.sparse</a> module. The library supports several different types of sparse matrix formats (along with operations for converting betweeen the different types), and interfaces with well-established third-party code for all needed linear algebra functions.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The standard library for manipulating sparse matrices with Python is the [scipy.sparse](https://docs.scipy.org/doc/scipy/reference/sparse.html) module.  The library supports several different types of sparse matrix formats (along with operations for converting betweeen the different types), and interfaces with well-established third-party code for all needed linear algebra functions.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::construct
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::construct
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s briefly look at how to construct a sparse matrix in <code>scipy.sparse</code> (we can convert to a dense matrix by calling the <code>.todense()</code> function, though of course this should only be done on small instances).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's briefly look at how to construct a sparse matrix in `scipy.sparse` (we can convert to a dense matrix by calling the `.todense()` function, though of course this should only be done on small instances).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::scipy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::scipy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">import</span> scipy.sparse <span class="im">as</span> sp</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">values <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-5" title="5">row_indices <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-6" title="6">column_indices <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-7" title="7">A <span class="op">=</span> sp.coo_matrix((values, (row_indices, column_indices)), shape<span class="op">=</span>(<span class="dv">4</span>,<span class="dv">4</span>))</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="bu">print</span>(A.todense())</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
import scipy.sparse as sp


values = [2, 4, 1, 3, 1, 1]
row_indices = [1, 3, 2, 0, 3, 1]
column_indices = [0, 0, 1, 2, 2, 3]
A = sp.coo_matrix((values, (row_indices, column_indices)), shape=(4,4))
print(A.todense())
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_100_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_99_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[[0 0 3 0]
 [2 0 0 1]
 [0 1 0 0]
 [4 0 1 0]]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[[0 0 3 0]
 [2 0 0 1]
 [0 1 0 0]
 [4 0 1 0]]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::access
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::access
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can directly access the values, rows indices, and column indices of a COO sparse matrix via the <code>.data</code>, <code>.row</code>, and <code>.col</code> properties respectively (indeed, this is exactly how the sparse matrix is represented internally, with these three attributes). Each of these are a 1D numpy array that store the data for the matrix.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can directly access the values, rows indices, and column indices of a COO sparse matrix via the `.data`, `.row`, and `.col` properties respectively (indeed, this is exactly how the sparse matrix is represented internally, with these three attributes).  Each of these are a 1D numpy array that store the data for the matrix.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::data
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::data
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(A.data)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(A.row)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(A.col)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(A.data)
print(A.row)
print(A.col)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_102_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_101_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[2 4 1 3 1 1]
[1 3 2 0 3 1]
[0 0 1 2 2 3]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[2 4 1 3 1 1]
[1 3 2 0 3 1]
[0 0 1 2 2 3]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::easily
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::easily
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can also easily convert to CSC format.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can also easily convert to CSC format.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::tocsc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::tocsc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">B <span class="op">=</span> A.tocsc()</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
B = A.tocsc()
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::pointer
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::pointer
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>For a CSC matrix, the values are in still in the <code>.data</code> pointer, but the row indices and column indices (as we used the terms), are in the <code>.indices</code> and <code>.indptr</code> arrays; again, this are all just numpy arrays, that internally store the actual data of the matrix.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
For a CSC matrix, the values are in still in the `.data` pointer, but the row indices and column indices (as we used the terms), are in the `.indices` and `.indptr` arrays; again, this are all just numpy arrays, that internally store the actual data of the matrix.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::indptr
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::indptr
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">print</span>(B.data)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">print</span>(B.indices)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bu">print</span>(B.indptr)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
print(B.data)
print(B.indices)
print(B.indptr)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::_104_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::_103_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
[2 4 1 3 1 1]
[1 3 2 0 3 1]
[0 2 3 5 6]
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
[2 4 1 3 1 1]
[1 3 2 0 3 1]
[0 2 3 5 6]
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::1000x1000
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::1000x1000
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>As a final example, let’s create a 1000x1000 sparse matrix with 99.9% sparsity plus an identity matrix (we’ll do this with the <code>sp.rand</code> call, which randomly chooses entries to fill in, and then makes samples them from a uniform distribution … we add the identity to make the matrix likely to be invertible). The precise nature of the matrix isn’t important here, we just want to consider the timing.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
As a final example, let's create a 1000x1000 sparse matrix with 99.9% sparsity plus an identity matrix (we'll do this with the `sp.rand` call, which randomly chooses entries to fill in, and then makes samples them from a uniform distribution ... we add the identity to make the matrix likely to be invertible).  The precise nature of the matrix isn't important here, we just want to consider the timing.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::rand
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::rand
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">A <span class="op">=</span> sp.rand(<span class="dv">1000</span>,<span class="dv">1000</span>, <span class="fl">0.001</span>) <span class="op">+</span> sp.eye(<span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb1-2" title="2">B <span class="op">=</span> np.asarray(A.todense())</a>
<a class="sourceLine" id="cb1-3" title="3">x <span class="op">=</span> np.random.randn(<span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">%</span>timeit A <span class="op">@</span> x</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="op">%</span>timeit B <span class="op">@</span> x</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
A = sp.rand(1000,1000, 0.001) + sp.eye(1000)
B = np.asarray(A.todense())
x = np.random.randn(1000)
%timeit A @ x
%timeit B @ x
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::runs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::runs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
12.8 µs ± 2.57 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
501 µs ± 73.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
12.8 µs ± 2.57 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
501 µs ± 73.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::version
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::version
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Here the sparse version is about 50x faster, though of course the speedup will increase with sparsity relative to the dense matrix.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Here the sparse version is about 50x faster, though of course the speedup will increase with sparsity relative to the dense matrix.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::spla
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::spla
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">import</span> scipy.sparse.linalg <span class="im">as</span> spla</a>
<a class="sourceLine" id="cb1-2" title="2">A <span class="op">=</span> A.tocsc()</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="op">%</span>timeit spla.spsolve(A,x)     <span class="co"># only works with CSC or CSR format</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">%</span>timeit np.linalg.solve(B,x)</a></code></pre></div>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
```python
import scipy.sparse.linalg as spla
A = A.tocsc()
%timeit spla.spsolve(A,x)     # only works with CSC or CSR format
%timeit np.linalg.solve(B,x)
```
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::loops
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::loops
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<pre>
1.04 ms ± 9.63 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
23.8 ms ± 2.39 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
<pre>
1.04 ms ± 9.63 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
23.8 ms ± 2.39 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::faster
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::faster
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Similarly, the sparse version is about 20x faster. You can try to experiment to see where the break-even point for the sparse/dense tradeoff is, but as mentioned above, for matrix inverses this is going to be very problem specific, so you won’t get too much insight until you start using real data.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Similarly, the sparse version is about 20x faster.  You can try to experiment to see where the break-even point for the sparse/dense tradeoff is, but as mentioned above, for matrix inverses this is going to be very problem specific, so you won't get too much insight until you start using real data.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
References
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
References
]]>
</field> <!-- title_src -->
<field name='label'>
sec:Vectors--matrices--and-linear-algebra::references
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:Vectors--matrices--and-linear-algebra::library
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:Vectors--matrices--and-linear-algebra::library
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<ul>
<li><a href="http://www.numpy.org">Numpy library</a></li>
<li><a href="http://www.cs.cmu.edu/~zkolter/course/linalg/">Linear Algebra Review</a></li>
<li><a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html">Numpy broadcasting rules</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/sparse.html">Scipy sparse module</a></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
- [Numpy library](http://www.numpy.org)
- [Linear Algebra Review](http://www.cs.cmu.edu/~zkolter/course/linalg/)
- [Numpy broadcasting rules](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html)
- [Scipy sparse module](https://docs.scipy.org/doc/scipy/reference/sparse.html)
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

</segment> <!-- chapter -->
